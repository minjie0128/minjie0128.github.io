<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="android , java">
<meta property="og:type" content="website">
<meta property="og:title" content="mike's 学习点滴">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="mike's 学习点滴">
<meta property="og:description" content="android , java">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mike's 学习点滴">
<meta name="twitter:description" content="android , java">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> mike's 学习点滴 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">mike's 学习点滴</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">小小码农一枚</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/Groovy学习笔记/" itemprop="url">
                  Groovy学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-18T22:24:30+08:00" content="2016-05-18">
              2016-05-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/18/Groovy学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/18/Groovy学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Groovy是一中运行在jvm上的动态语言<br>Groovy注释标记和Java一样，支持//或者/**/<br>Groovy语句可以不用分号结尾。Groovy为了尽量减少代码的输入，确实煞费苦心<br>Groovy中支持动态类型，即定义变量的时候可以不指定其类型。Groovy中，变量定义可以使用关键字def。注意，虽然def不是必须的，但是为了代码清晰，建议还是使用def关键字</p>
<pre><code>def variable1 = 1   //可以不使用分号结尾 
def  int x = 1  //变量定义时，也可以直接指定类型
</code></pre><p>当变量没有def等任何定义时，该变量全局有效。类似于javascript中的不用var定义的变量。</p>
<p>函数定义时，参数的类型也可以不指定。比如</p>
<pre><code>String testFunction(arg1,arg2){//无需指定参数类型
  ...
}
</code></pre><p>除了变量定义可以不指定类型外，Groovy中函数的返回值也可以是无类型的。比如：<br><strong>无类型的函数定义，必须使用def关键字</strong></p>
<pre><code>def  nonReturnTypeFunc(){
    last_line   //最后一行代码的执行结果就是本函数的返回值
}
</code></pre><p>如果指定了函数返回类型，则可不必加def关键字来定义函数</p>
<pre><code>String getString(){
   return&quot;I am a string&quot;
}
</code></pre><p>其实，所谓的无返回类型的函数，我估计内部都是按返回Object类型来处理的。毕竟，Groovy是基于Java的，而且最终会转成Java Code运行在JVM上</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>1  单引号’’中的内容严格对应Java中的String，不对$符号进行转义  </p>
<pre><code>defsingleQuote=&apos;I am $ dolloar&apos;  //输出就是I am $ dolloar
</code></pre><p>2  双引号””的内容则和脚本语言的处理有点像，如果字符中有$号的话，则它会$表达式先求值。  </p>
<pre><code>defdoubleQuoteWithoutDollar = &quot;I am one dollar&quot; //输出 I am one dollar  
def x = 1  
defdoubleQuoteWithDollar = &quot;I am $x dolloar&quot; //输出I am 1 dolloar  
</code></pre><p>3 三个引号’’’xxx’’’中的字符串支持随意换行 比如  </p>
<pre><code>defmultieLines = &apos;&apos;&apos; begin  
     line  1  
     line  2  
     end &apos;&apos;&apos;
</code></pre><p>最后，除了每行代码不用加分号外，Groovy中函数调用的时候还可以不加括号。比如：  </p>
<pre><code>println(&quot;test&quot;) ---&gt; println&quot;test&quot;  
</code></pre><p>调用函数要不要带括号，我个人意见是如果这个函数是Groovy API或者Gradle API中比较常用的，比如println，就可以不带括号。否则还是带括号。</p>
<h2 id="Groovy中的数据类型"><a href="#Groovy中的数据类型" class="headerlink" title="Groovy中的数据类型"></a>Groovy中的数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>作为动态语言，Groovy世界中的所有事物都是对象。所以，int，boolean这些Java中的基本数据类型，在Groovy代码中其实对应的是它们的包装数据类型。比如int对应为Integer，boolean对应为Boolean。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li>闭包中最后一行语句，表示该闭包的返回值，不论该语句是否冠名return关键字</li>
</ul>
<pre><code>def aClosure = {//闭包是一段代码，所以需要用花括号括起来..
Stringparam1, int param2 -&gt;  //这个箭头很关键。箭头前面是参数定义，箭头后面是代码
println&quot;this is code&quot; //这是代码，最后一句是返回值，
//也可以使用return，和Groovy中普通函数一样
}
</code></pre><p>闭包的调用</p>
<pre><code>aClosure(&quot;this is string&quot;, 100)  
</code></pre><ul>
<li>调用闭包的方法等于创建一个闭包实例。对于相同闭包创建出来的不同实例，他们的对象是不同的</li>
</ul>
<pre><code>v1 = c()  
v2 = c()  
assert v1 != v2  
</code></pre><ul>
<li>如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫it。</li>
</ul>
<p>比如：</p>
<pre><code>def greeting = { &quot;Hello, $it!&quot; }

assert greeting(&apos;Patrick&apos;) == &apos;Hello, Patrick!&apos;
等同于：
def greeting = { it -&gt; &quot;Hello, $it!&quot;}
assert greeting(&apos;Patrick&apos;) == &apos;Hello, Patrick!&apos;
但是，如果在闭包定义时，采用下面这种写法，则表示闭包没有参数！
def noParamClosure = { -&gt; true }
这个时候，我们就不能给noParamClosure传参数了！
noParamClosure (&quot;test&quot;)  &lt;==报错喔！
</code></pre><ul>
<li>省略圆括号</li>
</ul>
<p>Groovy中，当函数的最后一个参数是闭包的话，在调用该函数的时候可以把闭包拿到圆括号的外面<br>比如  </p>
<pre><code>def testClosure(int a1,String b1, Closure closure){  
     closure() //调用闭包  
}  
//那么调用的时候，就可以免括号！  
testClosure (4, &quot;test&quot;）{  
   println&quot;i am in closure&quot;  
} 
</code></pre><p>如果函数中只有一个参数，且该参数是闭包类型的话，在调用该函数的时候可以省略圆括号</p>
<pre><code>doLast{
    println &quot;Hello Word&quot;
}
//等同于
doLast({
    println &quot;Hello Word&quot;
})
</code></pre><p><strong>省略圆括号使得代码简洁，看起来更像脚本语言</strong></p>
<h2 id="Groovy脚步的运行原理"><a href="#Groovy脚步的运行原理" class="headerlink" title="Groovy脚步的运行原理"></a>Groovy脚步的运行原理</h2><p>Groovy和java一样，都是运行于jvm上的语言。所以Groovy语言在编译时，会被编译成jvm识别的classs文件。</p>
<p><img src="http://img.blog.csdn.net/20150905192824392?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>参考  <a href="http://blog.csdn.net/innost/article/details/48228651" target="_blank" rel="external">http://blog.csdn.net/innost/article/details/48228651</a></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/05/java-动态代理学习/" itemprop="url">
                  Java 动态代理学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-05T14:03:47+08:00" content="2016-05-05">
              2016-05-05
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/05/java-动态代理学习/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/05/java-动态代理学习/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java中代理分为2种， 静态代理和动态代理。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><img src="http://77fzym.com1.z0.glb.clouddn.com/proxy.png" alt=""></p>
<p>从图中可以看出，代理对象是客户端和真实对象之间的桥梁。代理对象要实现真实对象的所有公开方法（或者接口），而且当真实对象的接口修改的时候，代理对象也要做修改。而且在构造代理对象的时候，必须要知道真实对象。就是说代理对象和真实对象在编译时就已经绑定了。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>代理类获知或者被告知真实对象的类型、接口列表时，代理可以根据反射构造出真实对象来，进而调用真实对象的相应方法，这就是动态代理：<strong>代理类在编译时不需要知道具体要代理哪个真实对象，只有到了运行时才知道</strong>。</p>
<p>案例参考 <a href="http://www.cnblogs.com/flyoung2008/archive/2013/08/11/3251148.html" target="_blank" rel="external">http://www.cnblogs.com/flyoung2008/archive/2013/08/11/3251148.html</a></p>
<h3 id="Java字节码生成开源框架介绍–Javassist"><a href="#Java字节码生成开源框架介绍–Javassist" class="headerlink" title="Java字节码生成开源框架介绍–Javassist"></a><strong>Java字节码生成开源框架介绍–Javassist</strong></h3><p>Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目,通过使用Javassist对字节码操作为JBoss实现动态AOP框架。javassist是<a href="http://baike.baidu.com/view/309533.htm" target="_blank" rel="external">jboss</a>的一个子项目，其主要的优点，在于简单，而且快速。直接使用java编码的形式，而不需要了解虚拟机(但是ASM需要了解虚拟机指令)指令，就能动态改变类的结构，或者动态生成类。</p>
<pre><code>import javassist.ClassPool;  
import javassist.CtClass;  
import javassist.CtMethod;  
import javassist.CtNewMethod;  
public class MyGenerator {  

    public static void main(String[] args) throws Exception {  
        ClassPool pool = ClassPool.getDefault();  
        //创建Programmer类       
        CtClass cc= pool.makeClass(&quot;com.samples.Programmer&quot;);  
        //定义code方法  
        CtMethod method = CtNewMethod.make(&quot;public void code(){}&quot;, cc);  
        //插入方法代码  
        method.insertBefore(&quot;System.out.println(\&quot;I&apos;m a Programmer,Just Coding.....\&quot;);&quot;);  
        cc.addMethod(method);  
        //保存生成的字节码  
        cc.writeFile(&quot;d://temp&quot;);  
    }  
}  
</code></pre><p>通过JD-gui反编译工具打开Programmer.class 可以看到以下代码：</p>
<p><img src="http://77fzym.com1.z0.glb.clouddn.com/a.png" alt=""></p>
<h3 id="动态代理的内部实现"><a href="#动态代理的内部实现" class="headerlink" title="动态代理的内部实现"></a>动态代理的内部实现</h3><p>动态代理就是根据代理类实现的接口来动态生成class文件，然后根据这个class文件动态生成代理对象。</p>
<p>生成动态代理类的字节码并且保存到硬盘中：</p>
<p>JDK提供了<strong>sun.misc.ProxyGenerator.generateProxyClass(String proxyName,class[] interfaces)</strong> 底层方法来产生动态代理类的字节码：</p>
<p>下面定义了一个工具类，用来将生成的动态代理类保存到硬盘中：</p>
<pre><code>import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.Proxy;
import sun.misc.ProxyGenerator;

public class ProxyUtils {
/*
 * 将根据类信息 动态生成的二进制字节码保存到硬盘中，
 * 默认的是clazz目录下
     * params :clazz 需要生成动态代理类的类
     * proxyName : 为动态生成的代理类的名称
    &amp;nbsp;*/
public static void generateClassFile(Class clazz,String proxyName)
{
    //根据类信息和提供的代理类名称，生成字节码
    byte[] classFile =ProxyGenerator.generateProxyClass(proxyName, clazz.getInterfaces()); 
    String paths = clazz.getResource(&quot;.&quot;).getPath();
    System.out.println(paths);
    FileOutputStream out = null;  

    try {
        //保留到硬盘中
        out = new FileOutputStream(paths+proxyName+&quot;.class&quot;);  
        out.write(classFile);  
        out.flush();  
    } catch (Exception e) {  
        e.printStackTrace();  
    } finally {  
        try {  
            out.close();  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}
}
</code></pre><p>现在我们想将生成的代理类起名为“ElectricCarProxy”，并保存在硬盘，应该使用以下语句：</p>
<pre><code>ProxyUtils.generateClassFile(car.getClass(), &quot;ElectricCarProxy&quot;);
</code></pre><p>然后我们反编译生成的ElectricCarProxy.class文件,反编译之后看到的代码是：</p>
<p><strong>备注：代码中的 Subject接口 就是代理类实现的接口</strong></p>
<pre><code>import java.lang.reflect.*;   
public final class ProxySubject extends Proxy  implements Subject       
{   
    private static Method m1;   
    private static Method m0;   
    private static Method m3;   
    private static Method m2;   
    public ProxySubject(InvocationHandler invocationhandler)   
    {   
        super(invocationhandler);   
    }   
    public final boolean equals(Object obj)   
    {   
        try  
        {   
            return ((Boolean)super.h.invoke(this, m1, new Object[] {   
                obj   
            })).booleanValue();   
        }   
        catch(Error _ex) { }   
        catch(Throwable throwable)   
        {   
            throw new UndeclaredThrowableException(throwable);   
        }   
    }   
    public final int hashCode()   
    {   
        try  
        {   
            return ((Integer)super.h.invoke(this, m0, null)).intValue();   
        }   
        catch(Error _ex) { }   
        catch(Throwable throwable)   
        {   
            throw new UndeclaredThrowableException(throwable);   
        }   
    }   
    public final void doSomething()   
    {   
        try  
        {   
            super.h.invoke(this, m3, null);   
            return;   
        }   
        catch(Error _ex) { }   
        catch(Throwable throwable)   
        {   
            throw new UndeclaredThrowableException(throwable);   
        }   
    }   
    public final String toString()   
    {   
        try  
        {   
            return (String)super.h.invoke(this, m2, null);   
        }   
        catch(Error _ex) { }   
        catch(Throwable throwable)   
        {   
            throw new UndeclaredThrowableException(throwable);   
        }   
    }   
    static    
    {   
        try  
        {   
            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] {   
                Class.forName(&quot;java.lang.Object&quot;)   
            });   
            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);   
            m3 = Class.forName(&quot;Subject&quot;).getMethod(&quot;doSomething&quot;, new Class[0]);   
            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);   
        }   
        catch(NoSuchMethodException nosuchmethodexception)   
        {   
            throw new NoSuchMethodError(nosuchmethodexception.getMessage());   
        }   
        catch(ClassNotFoundException classnotfoundexception)   
        {   
            throw new NoClassDefFoundError(classnotfoundexception.getMessage());   
        }   
    }   
}
</code></pre><p>我们可以看到动态生成的ProxySubject 是继承Proxy类的。这就是<br><strong>为什么只能通过接口类来生成动态代理，而不是类来实现，因为java不支持多继承</strong>。<br>通过反编译之后的代码，我们可以看出调用代理类的一个方法时，代理类的方法会调用InvocationHandler的invoke方法，然后invoke方法再调用被代理对象的方法，所以我们在InvocationHandler的invoke方法的方法里做一些其它的处理操作，比如添加日志等等。</p>
<p>参考</p>
<p> <a href="http://blog.csdn.net/luanlouis/article/details/24589193" target="_blank" rel="external">http://blog.csdn.net/luanlouis/article/details/24589193</a></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/27/ADB-学习总结/" itemprop="url">
                  ADB 学习总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-27T16:39:10+08:00" content="2016-04-27">
              2016-04-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/27/ADB-学习总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/27/ADB-学习总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ADB 全称是Android Debug Bridge，android设备和模拟器是通过ADB来和PC机进行通信的，可以认为ADB是2者之间通信的桥梁。ADB采用的是cs模式来进行数据通信。</p>
<h2 id="ADB-有三个部分组成"><a href="#ADB-有三个部分组成" class="headerlink" title="ADB 有三个部分组成"></a>ADB 有三个部分组成</h2><ol>
<li>ADB客户端（DDMS）</li>
<li>ADB服务（运行在PC主机上 端口号5037）</li>
<li>adbd 守护服务（运行在模拟器或者android设备上)</li>
</ol>
<p><img src="http://77fzym.com1.z0.glb.clouddn.com/%E4%B8%8B%E8%BD%BD.png" alt="http://77fzym.com1.z0.glb.clouddn.com/%E4%B8%8B%E8%BD%BD.png"></p>
<p>当用户开始一个ADB客户端程序时，客户端首先会检查是否已经有一个 ADB 服务进程在运行，如果没有，它会启动一个服务进程；服务进程启动后，会与一个本地TCP端口5037进行绑定，并监听从ADB客户端发送过来的命令（所有的客户端都使用端口5037与服务进程进行通信）。</p>
<p>接着，服务端进程会配置所有正在运行的模拟器或者设备的链接：通过扫描5555 - 5585（模拟器/设备使用的端口范围）之间的奇数端口，服务端进程可以找到相应的模拟器/设备，接着找到相应的ADB守护进程，并对该端口进行配置。注意，每个模拟器/设备都需要一对连续的端口 - 奇数端口号用于ADB连接，偶数端口号用于控制台连接。</p>
<h2 id="Android设备ADB授权的原理"><a href="#Android设备ADB授权的原理" class="headerlink" title="Android设备ADB授权的原理"></a>Android设备ADB授权的原理</h2><p>用ADB调试Android设备时，首次连接时，会出现一个授权提示：</p>
<blockquote>
<p>error: device unauthorized. Please check the confirmation dialog on your device.</p>
</blockquote>
<p>这时候，正常情况下，在手机上会出现一个提示框，让用户确认是否授权这个PC设备允许调试，你只需要点击确认就可以了！</p>
<p><strong>工作原理是什么？</strong></p>
<p>在PC机上首次启动 ADB.exe进程时，ADB会在C盘的当前用户的目录下生成一个”.android”目录，生成一对密钥ADBkey(私钥)与ADBkey.pub(公钥)就存放在这个目录下。在电脑初次通过ADB和android设备通信的时候，PC端会把公钥(或者公钥的hash值)(fingerprint)发送给android设备，该公钥存放在android设备的”/data/misc/ADB/“目录下。当android设备的”/data/misc/ADB/“目录下已经存在该公钥时，就不发送这个文件，如果android设备没有这个文件的时候，就会发送PC上的公钥到android设备上的”/data/misc/ADB/“目录下，则会弹出提示框，让你确认是否允许这台机器进行ADB连接，当你点击了允许授权之后，android就会保存了这台PC的ADBkey.pub(公钥)；</p>
<p>参考 <a href="http://blog.csdn.net/sowhat_ah/article/details/43307907" target="_blank" rel="external">http://blog.csdn.net/sowhat_ah/article/details/43307907</a></p>
<h2 id="ADB常用命令"><a href="#ADB常用命令" class="headerlink" title="ADB常用命令"></a>ADB常用命令</h2><blockquote>
<p>查看已连接的设备<br>  adb devices</p>
</blockquote>
<hr>
<blockquote>
<p>安装软件<br>adb install <path_to_apk></path_to_apk></p>
</blockquote>
<hr>
<blockquote>
<p>拷贝文档到手机或者模拟器<br>adb push foo.txt /sdcard/foo.txt</p>
</blockquote>
<hr>
<blockquote>
<p>拷贝手机文件至电脑上<br>adb pull /sdcard/**.txt   D:\  </p>
</blockquote>
<hr>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/26/Binder的相关知识点/" itemprop="url">
                  Binder的相关知识点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-26T19:08:35+08:00" content="2016-04-26">
              2016-04-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/26/Binder的相关知识点/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/26/Binder的相关知识点/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p><strong>进程隔离</strong></p>
<blockquote>
<p>进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。</p>
</blockquote>
<p><strong>用户空间/内核空间</strong></p>
<p>简单理解如下：</p>
<p>Linux Kernel是操作系统的核心，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。</p>
<p>对于Kernel这么一个高安全级别的东西，显然是不容许其它的应用程序随便调用或访问的，所以需要对Kernel提供一定的保护机制，这个保护机制用来告诉那些应用程序，你只可以访问某些许可的资源，不许可的资源是拒绝被访问的，于是就把Kernel和上层的应用程序抽像的隔离开，分别称之为Kernel Space和User Space。</p>
<p>用户空间访问内核空间的唯一方式就是系统调用；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。</p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。处理器在特权等级高的时候才能执行那些特权CPU指令。</p>
<p>在Android系统中，这个运行在内核空间的，负责各个用户进程通过Binder通信的内核模块叫做Binder驱动  </p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/binder-model.png" alt=""></p>
<h3 id="Binder机制跨进程原理"><a href="#Binder机制跨进程原理" class="headerlink" title="Binder机制跨进程原理"></a>Binder机制跨进程原理</h3><p><strong>传统的2个用户空间的进程的通信方式</strong>：</p>
<blockquote>
<p>两个运行在用户空间的进程A和进程B如何完成通信呢？内核可以访问A和B的所有数据；所以，最简单的方式是通过内核做中转；假设进程A要给进程B发送数据，那么就先把A的数据copy到内核空间，然后把内核空间对应的数据copy到B就完成了；用户空间要操作内核空间，需要通过系统调用；刚好，这里就有两个系统调用：<em>copy_from_user</em>, <em>copy_to_user</em>。</p>
</blockquote>
<p><strong>Binder机制的通信原理</strong></p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/2016binder-procedure.png" alt=""></p>
<p>假设Client进程想要调用Server进程的object对象的一个方法add;对于这个跨进程通信过程，我们来看看Binder机制是如何做的。 （通信是一个广泛的概念，只要一个进程能调用另外一个进程里面某对象的方法，那么具体要完成什么通信内容就很容易了。）</p>
<p>首先，Server进程要向SM注册；告诉自己是谁，自己有什么能力；在这个场景就是Server告诉SM，它叫zhangsan，它有一个object对象，可以执行add 操作；于是SM建立了一张表：zhangsan这个名字对应进程Server;</p>
<p>然后Client向SM查询：我需要联系一个名字叫做zhangsan的进程里面的object对象；这时候关键来了：<strong>进程之间通信的数据都会经过运行在内核空间里面的驱动，驱动在数据流过的时候做了一点手脚</strong>，它并不会给Client进程返回一个真正的object对象，而是返回一个看起来跟object一模一样的代理对象objectProxy，这个objectProxy也有一个add方法，但是这个add方法没有Server进程里面object对象的add方法那个能力；objectProxy的add只是一个傀儡，它唯一做的事情就是把参数包装然后交给驱动。(这里我们简化了SM的流程，见下文)</p>
<p>但是Client进程并不知道驱动返回给它的对象动过手脚，毕竟伪装的太像了，如假包换。Client开开心心地拿着objectProxy对象然后调用add方法；我们说过，这个add什么也不做，直接把参数做一些包装然后直接转发给Binder驱动。</p>
<p>驱动收到这个消息，发现是这个objectProxy；一查表就明白了：我之前用objectProxy替换了object发送给Client了，它真正应该要访问的是object对象的add方法；于是Binder驱动通知Server进程，调用你的object对象的add方法，然后把结果发给我，Sever进程收到这个消息，照做之后将结果返回驱动，驱动然后把结果返回给Client进程；于是整个过程就完成了。</p>
<p>由于驱动返回的objectProxy与Server进程里面原始的object是如此相似，给人感觉好像是直接把Server进程里面的对象object传递到了Client进程；因此，我们可以说Binder对象是可以进行跨进程传递的对象</p>
<p>但事实上我们知道，Binder跨进程传输并不是真的把一个对象传输到了另外一个进程；传输过程好像是Binder跨进程穿越的时候，它在一个进程留下了一个真身，在另外一个进程幻化出一个影子（这个影子可以很多个）；Client进程的操作其实是对于影子的操作，影子利用<strong>Binder驱动</strong>最终让真身完成操作。</p>
<p>理解这一点非常重要；务必仔细体会。另外，Android系统实现这种机制使用的是代理模式, 对于Binder的访问，如果是在同一个进程（不需要跨进程），那么直接返回原始的Binder实体；如果在不同进程，那么就给他一个代理对象（影子）；我们在系统源码以及AIDL的生成代码里面可以看到很多这种实现。</p>
<p>另外我们为了简化整个流程，隐藏了SM这一部分驱动进行的操作；实际上，由于SM与Server通常不在一个进程，Server进程向SM注册的过程也是跨进程通信，驱动也会对这个过程进行暗箱操作：SM中存在的Server端的对象实际上也是代理对象，后面Client向SM查询的时候，驱动会给Client返回另外一个代理对象。Sever进程的本地对象仅有一个，其他进程所拥有的全部都是它的代理。</p>
<p>一句话总结就是：</p>
<blockquote>
<p>Client进程只不过是持有了Server端的代理；代理对象协助驱动完成了跨进程通信。</p>
</blockquote>
<h3 id="Binder到底是什么？"><a href="#Binder到底是什么？" class="headerlink" title="Binder到底是什么？"></a>Binder到底是什么？</h3><p>Binder的设计采用了面向对象的思想，在Binder通信模型的四个角色里面；他们的代表都是“Binder”，这样，对于Binder通信的使用者而言，Server里面的Binder和Client里面的Binder没有什么不同，一个Binder对象就代表了所有，它不用关心实现的细节，甚至不用关心驱动以及SM的存在；这就是抽象。</p>
<ul>
<li>通常意义下，Binder指的是一种通信机制；我们说AIDL使用Binder进行通信，指的就是Binder这种IPC机制。</li>
<li>对于Server进程来说，Binder指的是Binder本地对象</li>
<li>对于Client来说，Binder指的是Binder代理对象，它只是Binder本地对象的一个远程代理；对这个Binder代理对象的操作，会通过驱动最终转发到Binder本地对象上去完成；对于一个拥有Binder对象的使用者而言，它无须关心这是一个Binder代理对象还是Binder本地对象；对于代理对象的操作和对本地对象的操作对它来说没有区别。</li>
<li>对于传输过程而言，Binder是可以进行跨进程传递的对象；Binder驱动会对具有跨进程传递能力的对象做特殊处理：自动完成代理对象和本地对象的转换。</li>
</ul>
<blockquote>
<p>面向对象思想的引入将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体（本地对象）位于一个进程中，而它的引用（代理对象）却遍布于系统的各个进程之中。最诱人的是，这个引用和java里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给其它进程，让大家都能访问同一Server，就象将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的Binder对象以及星罗棋布的引用仿佛粘接各个应用程序的胶水，这也是Binder在英文里的原意。</p>
</blockquote>
<h3 id="驱动里面的Binder"><a href="#驱动里面的Binder" class="headerlink" title="驱动里面的Binder"></a>驱动里面的Binder</h3><p>我们现在知道，Server进程里面的Binder对象指的是Binder本地对象，Client里面的对象值得是Binder代理对象；在Binder对象进行跨进程传递的时候，Binder驱动会自动完成这两种类型的转换；因此Binder驱动必然保存了每一个跨越进程的Binder对象的相关信息；在驱动中，Binder本地对象的代表是一个叫做binder_node的数据结构，Binder代理对象是用binder_ref代表的；有的地方把Binder本地对象直接称作Binder实体，把Binder代理对象直接称作Binder引用（句柄），其实指的是Binder对象在驱动里面的表现形式；</p>
<h3 id="深入理解Java层的Binder"><a href="#深入理解Java层的Binder" class="headerlink" title="深入理解Java层的Binder"></a>深入理解Java层的Binder</h3><p><strong>IBinder/IInterface/Binder/BinderProxy/Stub</strong></p>
<p>我们使用AIDL接口的时候，经常会接触到这些类，那么这每个类代表的是什么呢？</p>
<ul>
<li>IBinder是一个接口，它代表了一种跨进程传输的能力；只要实现了这个接口，就能将这个对象进行跨进程传递；这是驱动底层支持的；在跨进程数据流经驱动的时候，驱动会识别IBinder类型的数据，从而自动完成不同进程Binder本地对象以及Binder代理对象的转换。</li>
<li>IBinder负责数据传输，那么client与server端的调用契约（这里不用接口避免混淆）呢？这里的IInterface代表的就是远程server对象具有什么能力。具体来说，就是aidl里面的接口。</li>
<li>Java层的Binder类，代表的其实就是Binder本地对象。BinderProxy类是Binder类的一个内部类，它代表远程进程的Binder对象的本地代理；这两个类都继承自IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder驱动会自动完成这两个对象的转换。</li>
<li>在使用AIDL的时候，编译工具会给我们生成一个Stub的静态内部类；这个类继承了Binder, 说明它是一个Binder本地对象，它实现了IInterface接口，表明它具有远程Server承诺给Client的能力；Stub是一个抽象类，具体的IInterface的相关实现需要我们手动完成，这里使用了策略模式。</li>
</ul>
<p> 参考：<a href="http://weishu.me/2016/01/12/binder-index-for-newer/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://weishu.me/2016/01/12/binder-index-for-newer/?utm_source=tuicool&amp;utm_medium=referral</a></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/14/Bitmap-Drawable-byte-三者之间的转换/" itemprop="url">
                  Bitmap,Drawable,byte[] 三者之间的转换
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-14T14:57:25+08:00" content="2016-04-14">
              2016-04-14
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/14/Bitmap-Drawable-byte-三者之间的转换/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/14/Bitmap-Drawable-byte-三者之间的转换/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Bitmap-gt-Drawable"><a href="#Bitmap-gt-Drawable" class="headerlink" title="Bitmap-&gt;Drawable"></a>Bitmap-&gt;Drawable</h3><pre><code>private Drawable transBitmapToBitmapDrawable(Bitmap bitmap){
    BitmapDrawable bd=new BitmapDrawable(getResources(),bitmap); 
    return bd;
}
</code></pre><blockquote>
<p>BitmapDrawable是Drawable的子类。</p>
</blockquote>
<h3 id="Drawable-gt-Bitmap"><a href="#Drawable-gt-Bitmap" class="headerlink" title="Drawable-&gt;Bitmap"></a>Drawable-&gt;Bitmap</h3><pre><code>private void drawableToBitamp(Drawable drawable){
     BitmapDrawable bd = (BitmapDrawable) drawable;
     bitmap = bd.getBitmap();
}
</code></pre><h3 id="Bitmap-gt-byte"><a href="#Bitmap-gt-byte" class="headerlink" title="Bitmap-&gt;byte[ ]"></a>Bitmap-&gt;byte[ ]</h3><pre><code>private byte[] transBitmapToByteArr(Bitmap bitmap){
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        bitmap.compress(Bitmap.CompressFormat.PNG, 100, baos);
        return baos.toByteArray();
}
</code></pre><p>在写这边文章的时候，有个小疑惑，为什么用的是 <strong>ByteArrayOutputStream</strong>，而不是 <strong>ByteArrayInputStream</strong>，因为 这个输入和输出是相对的概念。过程的执行体是 <strong>bitmap</strong>，当将 <strong>bitmap</strong> 的数据输出到 <strong>byte[]</strong> 这个过程，相对于 <strong>bitmap</strong> 来说是个输出的过程，所以用 <strong>ByteArrayOutputStream</strong> ， 这是我的理解。</p>
<h3 id="byte-gt-Bitmap"><a href="#byte-gt-Bitmap" class="headerlink" title="byte[ ] -&gt; Bitmap"></a>byte[ ] -&gt; Bitmap</h3><pre><code>private Bitmap transByteArrToBitmap(byte[] bytes){
    return BitmapFactory.decodeByteArray(bytes, 0, bytes.length);
}
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/12/我的第一篇hexo博客/" itemprop="url">
                  我的第一篇hexo博客
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-12T13:31:42+08:00" content="2016-04-12">
              2016-04-12
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/12/我的第一篇hexo博客/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/12/我的第一篇hexo博客/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>终于把hexo搭建好了，以后就可以用这个写博客了 !!!</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="mike" />
          <p class="site-author-name" itemprop="name">mike</p>
          <p class="site-description motion-element" itemprop="description">android , java</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/" target="_blank" title="GitHub">
                  
                    <i class="fa fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mike</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"MINJIE1"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
