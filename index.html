<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="android , java">
<meta property="og:type" content="website">
<meta property="og:title" content="mike's 学习点滴">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="mike's 学习点滴">
<meta property="og:description" content="android , java">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mike's 学习点滴">
<meta name="twitter:description" content="android , java">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> mike's 学习点滴 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">mike's 学习点滴</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">小小码农一枚</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/30/Android-Service-的启动过程的源码分析/" itemprop="url">
                  Android Service 的启动过程的源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-30T12:09:58+08:00" content="2016-07-30">
              2016-07-30
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/30/Android-Service-的启动过程的源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/30/Android-Service-的启动过程的源码分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>网上已经有很多篇关于Service启动源码分析的文章，我今天在这里也写下这篇文章，主要是为了在学习的过程中做个总结，便于以后复习查看。源码基于Android版本号15。为什么不选用最新的版本23，因为我觉得越新的版本，加入了越多的噪音代码，反而干扰了源码分析。</p>
<p>首先在AndroidManifest.xml中通过 android:process=”:remote” 将该Service配置为子进程服务，也就是说新开启的Service所在的进程和开启它的应用程序进程不是同一个进程。然后在Activity中通过startService来启动这个Service。</p>
<h2 id="Activity-startService"><a href="#Activity-startService" class="headerlink" title="Activity.startService()"></a>Activity.startService()</h2><p>由于是在Activity中调用 startService()，所以我们先看看Activity中startService()是如何调用的。首先借助Android Studio来看看调用Activity的继承关系图：<br><img src="http://77fzym.com1.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720160728152244.png" alt=""></p>
<p>通过上面的图我们可以看出Activity的父类是ContextThemeWrapper，ContextThemeWrapper的父类是ContextWrapper，ContextWrapper的父类是Context。通过查找我们发现startService方法的定义是在ContextWrapper类中。我们来看看 ContextWrapper类的startService()方法：</p>
<h2 id="ContextWrapper-startService"><a href="#ContextWrapper-startService" class="headerlink" title="ContextWrapper.startService()"></a>ContextWrapper.startService()</h2><pre><code>@Override
public ComponentName startService(Intent service) {
    return mBase.startService(service);
}
</code></pre><p>mBase这里指的是ContextImpl类，为什么是ContextImpl类，我会在后面给大家解释。我们来看看ContextImpl的startService()方法：</p>
<h2 id="ContextImpl-startService"><a href="#ContextImpl-startService" class="headerlink" title="ContextImpl.startService()"></a>ContextImpl.startService()</h2><pre><code>@Override
public ComponentName startService(Intent service) {

        ...
        ComponentName cn = ActivityManagerNative.getDefault().startService(
        mMainThread.getApplicationThread(), service,
        service.resolveTypeIfNeeded(getContentResolver()));
        ...

}
</code></pre><p>上面我省略了一些不重要的代码，只关注核心的代码。ActivityManagerNative.getDefault()返回的是 ActivityManagerProxy对象。参数mMainThread.getApplicationThread()返回ApplicationThread这个对象，ApplicationThread是个Binder对象，这个Binder对象是用来让服务进程和当前应用程序进程通信的，服务端后面就会用这个传递过来的Binder类型参数和客户端进程通信。这里的服务进程指的是ActivityManagerNative对象所在的进程。参数service是一个Intent对象。我们进入到ActivityManagerProxy对象的startService()方法：</p>
<h2 id="ActivityManagerProxy-startService"><a href="#ActivityManagerProxy-startService" class="headerlink" title="ActivityManagerProxy.startService()"></a>ActivityManagerProxy.startService()</h2><pre><code>public ComponentName startService(IApplicationThread caller, Intent service,
        String resolvedType) throws RemoteException
{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeStrongBinder(caller != null ? caller.asBinder() : null);
    service.writeToParcel(data, 0);
    data.writeString(resolvedType);
    mRemote.transact(START_SERVICE_TRANSACTION, data, reply, 0);
    reply.readException();
    ComponentName res = ComponentName.readFromParcel(reply);
    data.recycle();
    reply.recycle();
    return res;
}
</code></pre><p>这里关于Binder通信的代码，我这里不做介绍。这里我们要知道 ActivityManagerProxy是ActivityManagerNative对象的客户端代理对象。我们通过ActivityManagerProxy这个代理对象的操作最终都会转移到 ActivityManagerNative对象的onTransact方法中。在ActivityManagerNative类的onTransact方法中，有个switch语句</p>
<h2 id="在ActivityManagerNative-onTransact"><a href="#在ActivityManagerNative-onTransact" class="headerlink" title="在ActivityManagerNative.onTransact()"></a>在ActivityManagerNative.onTransact()</h2><pre><code>public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
      throws RemoteException {
  switch (code) {
  case START_ACTIVITY_TRANSACTION:
  {
</code></pre><p>通过方法的第一个参数code来找到需要执行的分支，这个code是ActivityManagerProxy类中通过 mRemote.transact(START_SERVICE_TRANSACTION,data,reply,0)传递过来的，所以当前code的值是START_SERVICE_TRANSACTION，我们找到case是 START_SERVICE_TRANSACTION 的分支</p>
<pre><code>case START_SERVICE_TRANSACTION: {
        data.enforceInterface(IActivityManager.descriptor);
        IBinder b = data.readStrongBinder();
        IApplicationThread app = ApplicationThreadNative.asInterface(b);
        Intent service = Intent.CREATOR.createFromParcel(data);
        String resolvedType = data.readString();
        ComponentName cn = startService(app, service, resolvedType);
        reply.writeNoException();
        ComponentName.writeToParcel(cn, reply);
        return true;
    }
</code></pre><p> IApplicationThread app = ApplicationThreadNative.asInterface(b); 这句代码表示把 b这个Binder对象转化成代理对象。然后调用startService(app,service,resolvedType)方法，由于ActivityManagerNative是个虚拟类，这个startService方法是在ActivityManagerNative的子类ActivityManagerService中实现的。进入到ActivityManagerService类的startService方法：</p>
<h2 id="ActivityManagerServic-startService"><a href="#ActivityManagerServic-startService" class="headerlink" title="ActivityManagerServic.startService()"></a>ActivityManagerServic.startService()</h2><pre><code>public ComponentName startService(IApplicationThread caller, Intent service,
        String resolvedType) {
    // Refuse possible leaked file descriptors
    if (service != null &amp;&amp; service.hasFileDescriptors() == true) {
        throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);
    }

    synchronized(this) {
        final int callingPid = Binder.getCallingPid();
        final int callingUid = Binder.getCallingUid();
        final long origId = Binder.clearCallingIdentity();
        ComponentName res = startServiceLocked(caller, service,
                resolvedType, callingPid, callingUid);
        Binder.restoreCallingIdentity(origId);
        return res;
    }
}
</code></pre><p>这个方法里调用了 startServiceLocked方法，进入到startServiceLocked方法：</p>
<h2 id="ActivityManagerServic-startServiceLocked"><a href="#ActivityManagerServic-startServiceLocked" class="headerlink" title="ActivityManagerServic.startServiceLocked()"></a>ActivityManagerServic.startServiceLocked()</h2><pre><code>ComponentName startServiceLocked(IApplicationThread caller,
        Intent service, String resolvedType,
        int callingPid, int callingUid) {
    synchronized(this) {
       。。。

        ServiceLookupResult res =
            retrieveServiceLocked(service, resolvedType,
                    callingPid, callingUid);
        。。。

        if (!bringUpServiceLocked(r, service.getFlags(), false)) {
            return new ComponentName(&quot;!&quot;, &quot;Service process is bad&quot;);
        }
        return r.name;

    }
}
</code></pre><p>这里只关注 retrieveServiceLocked 和 bringUpServiceLocked 这2个方法。 先看看 retrieveServiceLocked这个方法：</p>
<h2 id="ActivityManagerServic-retrieveServiceLocked"><a href="#ActivityManagerServic-retrieveServiceLocked" class="headerlink" title="ActivityManagerServic.retrieveServiceLocked()"></a>ActivityManagerServic.retrieveServiceLocked()</h2><pre><code> private ServiceLookupResult retrieveServiceLocked(Intent service,
       String resolvedType, int callingPid, int callingUid) {
               ServiceRecord r = null;

       。。。

       r = new ServiceRecord(this, ss, name, filter, sInfo, res);

       。。。
       if (checkComponentPermission(r.permission,
               callingPid, callingUid, r.appInfo.uid, r.exported)
               != PackageManager.PERMISSION_GRANTED) {

               if (!r.exported) {
               Slog.w(TAG, &quot;Permission Denial: Accessing service &quot; + r.name
                       + &quot; from pid=&quot; + callingPid
                       + &quot;, uid=&quot; + callingUid
                       + &quot; that is not exported from uid &quot; + r.appInfo.uid);
               return new ServiceLookupResult(null, &quot;not exported from uid &quot;
                       + r.appInfo.uid);
               }
               Slog.w(TAG, &quot;Permission Denial: Accessing service &quot; + r.name
                   + &quot; from pid=&quot; + callingPid
                   + &quot;, uid=&quot; + callingUid
                   + &quot; requires &quot; + r.permission);
               return new ServiceLookupResult(null, r.permission);
         }  
         return new ServiceLookupResult(r, null);
   }
   return null;
}
</code></pre><p>retrieveServiceLocked方法中通过 service这个Intent对象生成ServiceRecord对象。ServiceRecord对象代表了客户端Service在服务端ActivityManagerService中的记录。ServiceRecord对象里面记录着客户端Service所在的进程对象，包名等其它对象。 然后通过传递进来的 callingPid 和 callingUid 来判断当前pid和uid是否有权限来访问当前Service。我们再继续看 bringUpServiceLocked方法：</p>
<h2 id="ActivityManagerServic-bringUpServiceLocked"><a href="#ActivityManagerServic-bringUpServiceLocked" class="headerlink" title="ActivityManagerServic.bringUpServiceLocked()"></a>ActivityManagerServic.bringUpServiceLocked()</h2><pre><code>private final boolean bringUpServiceLocked(ServiceRecord r,
        int intentFlags, boolean whileRestarting) {
    。。。

    final String appName = r.processName;
    ProcessRecord app = getProcessRecordLocked(appName, r.appInfo.uid);
    if (app != null &amp;&amp; app.thread != null) {
        try {
            app.addPackage(r.appInfo.packageName);
            realStartServiceLocked(r, app);
            return true;
        } catch (RemoteException e) {

        }

    }

    // Not running -- get it started, and enqueue this service record
    // to be executed when the app comes up.
    if (startProcessLocked(appName, r.appInfo, true, intentFlags,
            &quot;service&quot;, r.name, false) == null) {
       。。。
    }

    if (!mPendingServices.contains(r)) {
        mPendingServices.add(r);
    }

    return true;
</code></pre><p>在bringUpServiceLocked方法中先调用getProcessRecordLocked方法，传递的参数是当前应用的包名和uid(uid是在安装的时候，PackageManagerService来分配的)。通过返回的ProcessRecord对象来判断当前Service所在的进程是否存在，因为在AndroidManifest.xml中通过 android:process=”:remote” 将该Service配置为子进程服务，所以当前Service所在的进程是肯定不存在。接下来通过startProcessLocked这个方法来创建进程来存放需要创建的Service对象。因为等下流程会跳转到客户端中去执行，所在这里需要用mPendingServices这个队列是保存当前未创建的ServiceRecord对象，等待后续继续处理。startProcessLocked方法这里有2个重载，一个是7个参数的，一个是3个参数的。这里先调7个参数的方法，在7个参数的方法中再调用3个参数的方法。这里7个参数方法没有什么这么好看的，这里我们直接进入到3个参数的startProcessLocked方法中：</p>
<h2 id="ActivityManagerServic-startProcessLocked"><a href="#ActivityManagerServic-startProcessLocked" class="headerlink" title="ActivityManagerServic.startProcessLocked()"></a>ActivityManagerServic.startProcessLocked()</h2><pre><code>private final void startProcessLocked(ProcessRecord app,
        String hostingType, String hostingNameStr) {

           。。。

        // Start the process.  It will either succeed and return a result containing
        // the PID of the new process, or else throw a RuntimeException.
        Process.ProcessStartResult startResult = Process.start(&quot;android.app.ActivityThread&quot;,
                app.processName, uid, uid, gids, debugFlags,
                app.info.targetSdkVersion, null);

        。。。


        synchronized (mPidsSelfLocked) {
            this.mPidsSelfLocked.put(startResult.pid, app);
            。。。
        }

}
</code></pre><p>这里关于创建进程的内容超过了本博客的范畴，这里我们只要知道在android中所有的java进程都是通过zygot进程fork出来的。Process.start方法的第一个参数是 “android.app.ActivityThread”。由此我们知道新创建的进程的主线程类是android.app.ActivityThread类。</p>
<pre><code>this.mPidsSelfLocked.put(startResult.pid, app); 
</code></pre><p>mPidsSelfLocked是个Map对象，把新创建的进程的pid作为key，进程对象作为value保存在mPidsSelfLocked中，方便下次查询。           </p>
<p>跟着流程我们进入到android.app.ActivityThread类的入口方法main方法中，这个main方法是新创建的进程的入口。</p>
<h2 id="ActivityThread-main"><a href="#ActivityThread-main" class="headerlink" title="ActivityThread.main()"></a>ActivityThread.main()</h2><pre><code>public static void main(String[] args) {

    。。。

    Looper.prepareMainLooper();

    。。。

    ActivityThread thread = new ActivityThread();
    thread.attach(false);

     。。。   

    Looper.loop();

}
</code></pre><p>Looper.prepareMainLooper(); 是为当前线程创建Looper对象，这就是为什么在主线程中创建Handler对象不需要首先创建Looper对象，因为这里已经创建了。</p>
<p>然后实例化当前的ActivityThread对象，然后调用attach方法：</p>
<h2 id="ActivityThread-attach"><a href="#ActivityThread-attach" class="headerlink" title="ActivityThread.attach()"></a>ActivityThread.attach()</h2><pre><code>private void attach(boolean system) {
    。。。
    if (!system) {
        。。。
        IActivityManager mgr = ActivityManagerNative.getDefault();
        try {
            mgr.attachApplication(mAppThread);
        } catch (RemoteException ex) {
            // Ignore
        }
    } else {
       。。。
    }

    。。。
}
</code></pre><p>因为syster参数在外面传进来是false,所以会执行 if分支里的代码，前面说过  ActivityManagerNative.getDefault() 返回的是ActivityManagerProxy对象，ActivityManagerProxy是服务端ActivityManagerNative在前端的代理对象，对于ActivityManagerProxy对象的方法调用会通过Binder驱动来调用ActivityManagerNative的onTransact方法。省去中间Binder调用的跳转我们直接进入到ActivityManagerService中的attachApplication方法中：</p>
<h2 id="ActivityManagerService-attachApplication"><a href="#ActivityManagerService-attachApplication" class="headerlink" title="ActivityManagerService.attachApplication()"></a>ActivityManagerService.attachApplication()</h2><pre><code>    public final void attachApplication(IApplicationThread thread) {
    synchronized (this) {
        int callingPid = Binder.getCallingPid();
        final long origId = Binder.clearCallingIdentity();
        attachApplicationLocked(thread, callingPid);
        Binder.restoreCallingIdentity(origId);
    }
}
</code></pre><p>里面调用 attachApplicationLocked(thread, callingPid);  </p>
<h2 id="ActivityManagerService-attachApplicationLocked"><a href="#ActivityManagerService-attachApplicationLocked" class="headerlink" title="ActivityManagerService.attachApplicationLocked()"></a>ActivityManagerService.attachApplicationLocked()</h2><pre><code>private final boolean attachApplicationLocked(IApplicationThread thread,
        int pid) {

    // Find the application record that is being attached...  either via
    // the pid if we are running in multiple processes, or just pull the
    // next app record if we are emulating process with anonymous threads.
    ProcessRecord app;
    if (pid != MY_PID &amp;&amp; pid &gt;= 0) {
        synchronized (mPidsSelfLocked) {
            app = mPidsSelfLocked.get(pid);
        }
    }

  。。。


thread.bindApplication(processName, appInfo, providers,
        app.instrumentationClass, profileFile, profileFd, profileAutoStop,
        app.instrumentationArguments, app.instrumentationWatcher, testMode, 
        isRestrictedBackupMode || !normalMode, app.persistent,
        new Configuration(mConfiguration), app.compat, getCommonServicesLocked(),
        mCoreSettingsObserver.getCoreSettingsLocked());

      。。。

    // Find any services that should be running in this process...
    if (!badApp &amp;&amp; mPendingServices.size() &gt; 0) {
        ServiceRecord sr = null;
        try {
            for (int i=0; i&lt;mPendingServices.size(); i++) {
                sr = mPendingServices.get(i);
                if (app.info.uid != sr.appInfo.uid
                        || !processName.equals(sr.processName)) {
                    continue;
                }

                mPendingServices.remove(i);
                i--;
                realStartServiceLocked(sr, app);

            }
        } catch (Exception e) {
         。。。
        }
    }

 。。。

    return true;
} 
</code></pre><p>先通过传递进来的pid参数在mPidsSelfLocked这个Map中找到对应的ProcessRecord对象。attachApplicationLocked方法里面调用了2个重要的方法，thread.bindApplication() 和 realStartServiceLocked()。我们先看看thread.bindApplication()方法，这里的thread是一个实现了IApplicationThread接口的对象，实际上是ApplicationThreadProxy对象，这个对象也是个Binder代理对象，调用它的方法会通过Binder驱动会调用到ApplicationThreadNative对象的onTransact()方法中去。ApplicationThreadNative和ActivityManagerNative一样，也是个抽象类，ApplicationThreadNative里面的抽象方法是在ApplicationThread类里面实现的。省去中间Binder调用的步骤，直接进入到ApplicationThread类的bindApplication方法里面,ApplicationThread类是ActivityThread的内部类。</p>
<h2 id="ApplicationThread-bindApplication"><a href="#ApplicationThread-bindApplication" class="headerlink" title="ApplicationThread.bindApplication()"></a>ApplicationThread.bindApplication()</h2><pre><code>public final void bindApplication(String processName,
            ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers,
            ComponentName instrumentationName, String profileFile,
            ParcelFileDescriptor profileFd, boolean autoStopProfiler,
            Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher,
            int debugMode, boolean isRestrictedBackupMode, boolean persistent,
            Configuration config, CompatibilityInfo compatInfo,
            Map&lt;String, IBinder&gt; services, Bundle coreSettings) {

        if (services != null) {
            // Setup the service cache in the ServiceManager
            ServiceManager.initServiceCache(services);
        }

        setCoreSettings(coreSettings);

        AppBindData data = new AppBindData();
        data.processName = processName;
        data.appInfo = appInfo;
        data.providers = providers;
        data.instrumentationName = instrumentationName;
        data.instrumentationArgs = instrumentationArgs;
        data.instrumentationWatcher = instrumentationWatcher;
        data.debugMode = debugMode;
        data.restrictedBackupMode = isRestrictedBackupMode;
        data.persistent = persistent;
        data.config = config;
        data.compatInfo = compatInfo;
        data.initProfileFile = profileFile;
        data.initProfileFd = profileFd;
        data.initAutoStopProfiler = false;
        queueOrSendMessage(H.BIND_APPLICATION, data);
    }
</code></pre><p>通过queueOrSendMessage方法，把AppBindData对象放到主线程的消息队列中去，H是定义在ActivityThread类里面的一个Handler对象，进入到H的handleMessage方法中去，找到case是 H.BIND_APPLICATION 的switch分支：</p>
<pre><code>case BIND_APPLICATION:
                AppBindData data = (AppBindData)msg.obj;
                handleBindApplication(data);
                break;
</code></pre><p>进入到ActivityThread类的handleBindApplication方法里面去</p>
<h2 id="ActivityThread-handleBindApplication"><a href="#ActivityThread-handleBindApplication" class="headerlink" title="ActivityThread.handleBindApplication()"></a>ActivityThread.handleBindApplication()</h2><pre><code>private void handleBindApplication(AppBindData data) {

    。。。

    // If the app is being launched for full backup or restore, bring it up in
    // a restricted environment with the base application class.
    Application app = data.info.makeApplication(data.restrictedBackupMode, null);


    try {
        mInstrumentation.callApplicationOnCreate(app);
    } catch (Exception e) {

    }
}
</code></pre><p>data.info 是一个LoadedApk对象，进入到LoadedApk类的makeApplication方法</p>
<h2 id="LoadedApk-makeApplication"><a href="#LoadedApk-makeApplication" class="headerlink" title="LoadedApk.makeApplication()"></a>LoadedApk.makeApplication()</h2><pre><code>public Application makeApplication(boolean forceDefaultAppClass,
        Instrumentation instrumentation) {
    if (mApplication != null) {
        return mApplication;
    }

    Application app = null;

     String appClass = mApplicationInfo.className;
    if (forceDefaultAppClass || (appClass == null)) {
        appClass = &quot;android.app.Application&quot;;
    }

    try {
        java.lang.ClassLoader cl = getClassLoader();
        ContextImpl appContext = new ContextImpl();
        appContext.init(this, null, mActivityThread);
        app = mActivityThread.mInstrumentation.newApplication(
                cl, appClass, appContext);
        appContext.setOuterContext(app);
    } catch (Exception e) {
        if (!mActivityThread.mInstrumentation.onException(app, e)) {
            throw new RuntimeException(
                &quot;Unable to instantiate application &quot; + appClass
                + &quot;: &quot; + e.toString(), e);
        }
    }

    mApplication = app;

    return app;
}
</code></pre><p>方法的开始处判断当前应用程序的Application对象是否已经创建，如果已经创建了直接返回。appClass代表的是在清单文件中配置的Application对象，如果没有指定就使用默认的android.app.Application类，通过getClassLoader()方法获得的ClassLoad来加载Application类。我们返回到上面的handleBindApplication方法，接着看下面的</p>
<pre><code>try {
        mInstrumentation.callApplicationOnCreate(app);
    } catch (Exception e) {

    }
</code></pre><p>mInstrumentation是Instrumentation对象。对Application和Activity对象的生命周期的控制都是通过这个Instrumentation类来进行的。网上有人说Instrumentation的作用类似一个管家。进入到Instrumentation类的callApplicationOnCreate方法里面</p>
<h2 id="Instrumentation-callApplicationOnCreate"><a href="#Instrumentation-callApplicationOnCreate" class="headerlink" title="Instrumentation.callApplicationOnCreate()"></a>Instrumentation.callApplicationOnCreate()</h2><pre><code>public void callApplicationOnCreate(Application app) {
    app.onCreate();
}
</code></pre><p>这个方法非常简单，就一段代码，就是调用app.onCreate()方法。从handleBindApplication这个方法开始的几个流程我们看出这个方法就是创建当前应用进程的Application对象然后调用这个对象的onCreate()方法。<strong>由于Binder通信是阻塞的，所以app.onCreate()方法里不应该做一些耗时的操作</strong>。我们接着返回到ActivityManagerService对象的attachApplicationLocked方法里面，我们已经讲完了thread.bindApplication这个步骤，接着看realStartServiceLocked这个方法的调用过程。realStartServiceLocked(sr,app)方法的第一个参数sr是一个ServiceRecord对象。这个sr来自于mPendingServices这个ArrayList对象里面，前面说过mPendingServices队列保存了待处理的ServiceRecord对象。我们进入到realStartServiceLocked方面里面</p>
<h2 id="ActivityManagerService-realStartServiceLocked"><a href="#ActivityManagerService-realStartServiceLocked" class="headerlink" title="ActivityManagerService.realStartServiceLocked()"></a>ActivityManagerService.realStartServiceLocked()</h2><pre><code>    private final void realStartServiceLocked(ServiceRecord r,
        ProcessRecord app) throws RemoteException {

        。。。

    try {

      。。。

        app.thread.scheduleCreateService(r, r.serviceInfo,
                compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo));

    } finally {

    }

}
</code></pre><p>这里面最重要的一句话 </p>
<pre><code>app.thread.scheduleCreateService(r, r.serviceInfo,
                compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo));
</code></pre><p>这也是一个Binder通信。通过上面的解释我们知道这个Binder通信最终会调用到ApplicationThread类里面的方法，我们省去中间调用的步骤，直接进入到 ApplicationThread类的scheduleCreateService方法</p>
<h2 id="ApplicationThread-scheduleCreateService"><a href="#ApplicationThread-scheduleCreateService" class="headerlink" title="ApplicationThread.scheduleCreateService()"></a>ApplicationThread.scheduleCreateService()</h2><pre><code>public final void scheduleCreateService(IBinder token,
            ServiceInfo info, CompatibilityInfo compatInfo) {
        CreateServiceData s = new CreateServiceData();
        s.token = token;
        s.info = info;
        s.compatInfo = compatInfo;

        queueOrSendMessage(H.CREATE_SERVICE, s);
    }
</code></pre><p>这里面是一个Handler通信。我们直接进入到H对象handleMessage方法中，找到case是H.CREATE_SERVICE的分支</p>
<pre><code>case CREATE_SERVICE:
                handleCreateService((CreateServiceData)msg.obj);
                break;
</code></pre><p>这里没调用了 handleCreateService方法，进入到handleCreateService方法</p>
<h2 id="ActivityThread-handleCreateService"><a href="#ActivityThread-handleCreateService" class="headerlink" title="ActivityThread.handleCreateService()"></a>ActivityThread.handleCreateService()</h2><pre><code>private void handleCreateService(CreateServiceData data) {


    try {
        java.lang.ClassLoader cl = packageInfo.getClassLoader();
        service = (Service) cl.loadClass(data.info.name).newInstance();
    } catch (Exception e) {
        if (!mInstrumentation.onException(service, e)) {
            throw new RuntimeException(
                &quot;Unable to instantiate service &quot; + data.info.name
                + &quot;: &quot; + e.toString(), e);
        }
    }

    try {

        ContextImpl context = new ContextImpl();
        context.init(packageInfo, null, this);


        context.setOuterContext(service);
        service.attach(context, this, data.info.name, data.token, app,
                ActivityManagerNative.getDefault());
        service.onCreate();
        mServices.put(data.token, service);
        。。。
    } catch (Exception e) {
        if (!mInstrumentation.onException(service, e)) {
            throw new RuntimeException(
                &quot;Unable to create service &quot; + data.info.name
                + &quot;: &quot; + e.toString(), e);
        }
    }
}
</code></pre><p>方法的开始处先通过ClassLoader加载需要创建的Service类，然后通过newInstance()来实例化。然后接着创建 ContextImpl 对象。然后把ContextImpl对象作为参数调用 service.attach 的方法，进入service.attach方法</p>
<h2 id="Service-attach"><a href="#Service-attach" class="headerlink" title="Service.attach()"></a>Service.attach()</h2><pre><code>public final void attach(
        Context context,
        ActivityThread thread, String className, IBinder token,
        Application application, Object activityManager) {
    attachBaseContext(context);
    mThread = thread;           // NOTE:  unused - remove?
    mClassName = className;
    mToken = token;
    mApplication = application;
    mActivityManager = (IActivityManager)activityManager;
    mStartCompatibility = getApplicationInfo().targetSdkVersion &lt; Build.VERSION_CODES.ECLAIR;

}
</code></pre><p>通过传进来的参数对Service对象进行初始化操作。方法里面调用了 attachBaseContext(context); 方法，我们进入到attachBaseContext方法</p>
<h2 id="ContextWrapper-attachBaseContext"><a href="#ContextWrapper-attachBaseContext" class="headerlink" title="ContextWrapper.attachBaseContext()"></a>ContextWrapper.attachBaseContext()</h2><pre><code>protected void attachBaseContext(Context base) {
    if (mBase != null) {
        throw new IllegalStateException(&quot;Base context already set&quot;);
    }
    mBase = base;
}
</code></pre><p>这个方法的定义是在Service的父类ContextWrapper中定义的。把base参数赋值给mBase这个变量。这个base就是ContextImpl对象。这就解释我在文章一开始处留下的问题。我们接着返回到 handleCreateService方法中，调用了Service的attach方法之后，接着调用了Service的onCreate方法。然后把CreateServiceData参数的token字段作为key，service作为value保存到mServices这个字典中。</p>
<p>到此，基本上已经把Service的启动过程分析完了。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/23/Smali学习笔记/" itemprop="url">
                  Smali学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-23T07:35:19+08:00" content="2016-07-23">
              2016-07-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/23/Smali学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/23/Smali学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是Smali"><a href="#什么是Smali" class="headerlink" title="什么是Smali"></a>什么是Smali</h2><p>由于Android开发是基于java语言开发的，然后运行在dalvik虚拟机上面。dalvik和jvm一样，不能识别java代码，只能识别java编译成的中间代码，在android平台上，这个中间代码就是Smali。通过学习Smali指令我们可以了解代码的运行过程。</p>
<h2 id="Smali分析"><a href="#Smali分析" class="headerlink" title="Smali分析"></a>Smali分析</h2><p>我们从一个简单的例子来分析Smali，我写了一个非常简单的demo，</p>
<pre><code>public class MainActivity extends Activity {

    Button btn;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        btn=(Button)findViewById(R.id.btn);

        btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Toast.makeText(MainActivity.this,&quot;Hello World&quot;,Toast.LENGTH_SHORT).show();
            }
        });
    }
}
</code></pre><p>demo非常简单，就是点击一个Button，弹出一个Hello World的Toast。然后通过apktool来反编译这个程序的Apk文件，反编译成功之后，会生成一个和Apk同名的文件夹，在这个文件夹中我们会看到一个名为smali的文件夹，这个smali文件夹中的目录结构和java源文件的目录结构是一样的。顺着目录我们会看到MainActivity.smali 和 MainActivity$1.smali这2个文件。为什么会有MainActivity$1.smali这个文件呢，因为在给btn按钮注册回调事件是一个匿名内部内，在java中每一个内部类编译之后都会单独生成一个文件，内部类文件的命名是用$符号来命名的。 比如：主类名+$+序号。<br>先打开MainActivity.smali这个文件,文件的内容如下：</p>
<pre><code>.class public Lcom/mj/mjapp/MainActivity;
.super Landroid/app/Activity;
.source &quot;MainActivity.java&quot;


# instance fields
.field btn:Landroid/widget/Button;


# direct methods
.method public constructor &lt;init&gt;()V
    .locals 0

    .prologue
    .line 9
    invoke-direct {p0}, Landroid/app/Activity;-&gt;&lt;init&gt;()V

    return-void
.end method


# virtual methods
.method protected onCreate(Landroid/os/Bundle;)V
    .locals 2
    .param p1, &quot;savedInstanceState&quot;    # Landroid/os/Bundle;

    .prologue
    .line 15
    invoke-super {p0, p1}, Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle;)V

    .line 16
    const/high16 v0, 0x7f030000

    invoke-virtual {p0, v0}, Lcom/mj/mjapp/MainActivity;-&gt;setContentView(I)V

    .line 18
    const/high16 v0, 0x7f070000

    invoke-virtual {p0, v0}, Lcom/mj/mjapp/MainActivity;-&gt;findViewById(I)Landroid/view/View;

    move-result-object v0

    check-cast v0, Landroid/widget/Button;

    iput-object v0, p0, Lcom/mj/mjapp/MainActivity;-&gt;btn:Landroid/widget/Button;

    .line 20
    iget-object v0, p0, Lcom/mj/mjapp/MainActivity;-&gt;btn:Landroid/widget/Button;

    new-instance v1, Lcom/mj/mjapp/MainActivity$1;

    invoke-direct {v1, p0}, Lcom/mj/mjapp/MainActivity$1;-&gt;&lt;init&gt;(Lcom/mj/mjapp/MainActivity;)V

    invoke-virtual {v0, v1}, Landroid/widget/Button;-&gt;setOnClickListener(Landroid/view/View$OnClickListener;)V

    .line 26
    return-void
.end method
</code></pre><p>最前面的三行是对当前类的介绍信息。当前类是 Lcom/mj/mjapp/MainActivity; 父类是 Landroid/app/Activity; 当前类的源文件是 MainActivity.java。</p>
<p><strong>smali类型介绍</strong><br> 在smali中，数据类型和Android中的一样，只是对应的符号有变化：</p>
<blockquote>
<p>B—byte</p>
<p>C—char</p>
<p>D—double</p>
<p>F—float</p>
<p>I—int</p>
<p>J—long</p>
<p>S—short</p>
<p>V—void</p>
<p>Z—boolean</p>
<p>[XXX—array</p>
<p>Lxxx/yyy—object </p>
</blockquote>
<p>这里解析下最后两项，数组的表示方式是：在基本类型前加上前中括号“[”，例如int数组和float数组分别表示为：[I、[F；对象的表示则以L作为开头，格式是LpackageName/objectName;（注意必须有个分号跟在最后），例如String对象在smali中为：Ljava/lang/String;，其中java/lang对应java.lang包，String就是定义在该包中的一个对象。所以上面用 <strong>Lcom/mj/mjapp/MainActivity;</strong> 来表示对象，而且末尾用 <strong>;</strong> 。<br>接着继续往下介绍，</p>
<pre><code># instance fields
.field btn:Landroid/widget/Button;
</code></pre><p>这个代表声明的实例字段，如果是静态字段用 # static fields 来表示，定义字段的格式是： <strong>.field public/private [static] [final] varName:&lt;类型&gt;</strong> 。</p>
<p>继续往下介绍，</p>
<pre><code># direct methods
.method public constructor &lt;init&gt;()V
    .locals 0

    .prologue
    .line 9
    invoke-direct {p0}, Landroid/app/Activity;-&gt;&lt;init&gt;()V

    return-void
.end method
</code></pre><p>函数的定义一般为：</p>
<pre><code>Func-Name (Para-Type1Para-Type2Para-Type3...)Return-Type

注意参数与参数之间没有任何分隔符，同样举几个例子就容易明白了：

1. foo ()V

    没错，这就是void foo()。

2. foo (III)Z

    这个则是boolean foo(int, int, int)。

3. foo (Z[I[ILjava/lang/String;J)Ljava/lang/String;

    看出来这是String foo (boolean, int[], int[], String, long) 了吗？
</code></pre><p>在smali中 方法的类型 分为3种 ： direct methods，virtual methods和static methods。 构造方法或者是private修饰的方法属于direct methods，静态方法属于static methods, 用public或protected修饰的方法就是属于virtual methods。</p>
<p>现在返回到方法本身   <strong><init>（）</init></strong>表示的是构造方法。 </p>
<ul>
<li><p>.locals 0 表示的是需要 0个本地寄存器变量 。如果当前方法需要3个本地变量，就是 .locals 3 。</p>
</li>
<li><p>.prologue 表示方法的开始。</p>
</li>
<li><p>.line 9 表示当前的源码对应源码的第9行。 一些混淆后的代码有可能是没有 .prologue 和  .line 9的。真是有了这个，我们才可以在异常栈中看到哪个方法的哪一行出现了异常，才可以快速的定位到出现异常的代码。</p>
</li>
<li><p>invoke-direct {p0}, Landroid/app/Activity;-&gt;<init>()V </init></p>
</li>
</ul>
<blockquote>
<p>Dalvik VM与JVM的最大的区别之一就是Dalvik VM是基于寄存器的。基于寄存器是什么意思呢？也就是说，在smali里的所有操作都必须经过寄存器来进行：本地寄存器用v开头数字结尾的符号来表示，如v0、v1、v2、…参数寄存器则使用p开头数字结尾的符号来表示，如p0、p1、p2、…特别注意的是，p0不一定是函数中的第一个参数，在非static函数中，p0代指“this”，p1表示函数的第一个参数，p2代表函数中的第二个参数…而在static函数中p0才对应第一个参数（因为Java的static方法中没有this指针）。</p>
</blockquote>
<p>这里的 P0代表的是当前的this对象，这行代码表示 调用Landroid/app/Activity;类的<init>()方法，且传递的参数是p0对象。</init></p>
<ul>
<li>return-void</li>
<li>end method</li>
</ul>
<p>上面2行表示函数返回void和函数的结束。</p>
<p>接着往下看：</p>
<pre><code># virtual methods
.method protected onCreate(Landroid/os/Bundle;)V
    .locals 2
    .param p1, &quot;savedInstanceState&quot;    # Landroid/os/Bundle;

    .prologue
    .line 15
    invoke-super {p0, p1}, Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle;)V

    .line 16
    const/high16 v0, 0x7f030000

    invoke-virtual {p0, v0}, Lcom/mj/mjapp/MainActivity;-&gt;setContentView(I)V

    .line 18
    const/high16 v0, 0x7f070000

    invoke-virtual {p0, v0}, Lcom/mj/mjapp/MainActivity;-&gt;findViewById(I)Landroid/view/View;

    move-result-object v0

    check-cast v0, Landroid/widget/Button;

    iput-object v0, p0, Lcom/mj/mjapp/MainActivity;-&gt;btn:Landroid/widget/Button;

    .line 20
    iget-object v0, p0, Lcom/mj/mjapp/MainActivity;-&gt;btn:Landroid/widget/Button;

    new-instance v1, Lcom/mj/mjapp/MainActivity$1;

    invoke-direct {v1, p0}, Lcom/mj/mjapp/MainActivity$1;-&gt;&lt;init&gt;(Lcom/mj/mjapp/MainActivity;)V

    invoke-virtual {v0, v1}, Landroid/widget/Button;-&gt;setOnClickListener(Landroid/view/View$OnClickListener;)V

    .line 26
    return-void
.end method
</code></pre><p>当前的方法的名字是onCreate，是个protected方法，返回类型是void， 参数的类型是Landroid/os/Bundle;。</p>
<ul>
<li>.locals 2 表示当前方法需要2个本地寄存器变量，这2个变量不包括形参变量，这里为什么需要2个本地寄存器变量我会在后面介绍。</li>
<li>.param p1, “savedInstanceState”    # Landroid/os/Bundle; 在前面说过 p0表示隐藏的参数，P1才表示当前方法的第一个参数，源码中的参数名是 savedInstanceState。</li>
<li>invoke-super {p0, p1}, Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle;)V  invoke-super指令 表示调用父类的onCreate方法，{p0, p1}表示传递的参数。</li>
<li>const/high16 v0, 0x7f030000  const指令表示赋值操作，把0x7f030000赋值给v0，其实0x7f030000 对应的值就是 R.layout.activity_main 这个int类型的值。 const/high16 这个地方的high16我暂时不知道是什么意思。如果哪位网友知道的话，请在评论下面回复我。</li>
<li>invoke-virtual {p0, v0}, Lcom/mj/mjapp/MainActivity;-&gt;setContentView(I)V  调用setContentView() 方法，把上一步中的v0变量当作这次调用的参数传递给setContentView()方法。</li>
<li>const/high16 v0, 0x7f070000 继续给v0赋值，新的值会覆盖旧的值。</li>
<li>invoke-virtual {p0, v0}, Lcom/mj/mjapp/MainActivity;-&gt;findViewById(I)Landroid/view/View; 调用findViewById()方法。这个方法的返回类型是 Landroid/view/View;</li>
<li>move-result-object v0<blockquote>
<p>在Java代码中调用函数和返回函数结果是一条语句完成的，而在smali里则需要分开来完成，在使用上述指令后，如果调用的函数返回非void，那么还需要用到move-result（返回基本数据类型）和move-result-object（返回对象）指令。</p>
</blockquote>
</li>
</ul>
<p>因为 findViewById()方法返回一个View对象，所以需要调用 move-result-object这个指令，再把返回的值赋值给v0变量。我们发现申请的一个变量是可以重复使用的。</p>
<ul>
<li>check-cast v0, Landroid/widget/Button; check-cast指令表示的是 类型转化。因为v0表示的是View类型，需要将其转化成Button类型。</li>
<li>iput-object v0, p0, Lcom/mj/mjapp/MainActivity;-&gt;btn:Landroid/widget/Button; <blockquote>
<p>一般来说，获取值的指令有：iget、sget、iget-boolean、sget-boolean、iget-object、sget-object等，设置值操作的指令有：iput、sput、iput-boolean、sput-boolean、iput-object、sput-object等。没有“-object”后缀的表示操作的成员变量对象是基本数据类型，带“-object”表示操作的成员变量是对象类型，特别地，boolean类型则使用带“-boolean”的指令操作。iget表示的是获得实例变量的值，sget表示的是活的静态变量的值。同理 iput和sput表示设置实例变量和静态变量的值。iput和iget指令操作的是实例变量，而sput和sget指令操作的是静态变量。所以iput和iget指令会比sput和sget指令多一个参数，多出的这个参数表示当前的操作的实例变量属于哪个对象。多出的那个参数是在iput和iget指令三个参数中的中间的那个参数。</p>
</blockquote>
</li>
</ul>
<p>上面指令的意思是把v0变量赋值给p0对象的btn变量。</p>
<ul>
<li>iget-object v0, p0, Lcom/mj/mjapp/MainActivity;-&gt;btn:Landroid/widget/Button; 这个是把p0对象的btn变量赋值给 v0变量。</li>
<li>new-instance v1, Lcom/mj/mjapp/MainActivity$1; 实例化Lcom/mj/mjapp/MainActivity$1;这个内部类变量，然后赋值给v1这个变量。Lcom/mj/mjapp/MainActivity$1;类里面smali代码我等下会介绍。</li>
<li>invoke-direct {v1, p0}, Lcom/mj/mjapp/MainActivity$1;-&gt;<init>(Lcom/mj/mjapp/MainActivity;)V 调用内部类的构造方法。</init></li>
<li>invoke-virtual {v0, v1}, Landroid/widget/Button;-&gt;setOnClickListener(Landroid/view/View$OnClickListener;)V 调用Button对象的setOnClickListener()方法。</li>
</ul>
<p>现在我们返回到方法开始处的 .locals 2 的问题，因为该方法中 申请了 v0 和v1 2个本地寄存器变量，所以是 .locals 2。如果把2改成3，那么重新打包运行会得到一个VerifyError错误。<br>我们已经分析完了MainActivity.smali 这个文件中的smali代码，接着继续分析MainActivity$1.smali中的代码。</p>
<p>MainActivity$1.smali代码如下：</p>
<pre><code>.class Lcom/mj/mjapp/MainActivity$1;
.super Ljava/lang/Object;
.source &quot;MainActivity.java&quot;

# interfaces
.implements Landroid/view/View$OnClickListener;


# annotations
.annotation system Ldalvik/annotation/EnclosingMethod;
    value = Lcom/mj/mjapp/MainActivity;-&gt;onCreate(Landroid/os/Bundle;)V
.end annotation

.annotation system Ldalvik/annotation/InnerClass;
    accessFlags = 0x0
    name = null
.end annotation


# instance fields
.field final synthetic this$0:Lcom/mj/mjapp/MainActivity;


# direct methods
.method constructor &lt;init&gt;(Lcom/mj/mjapp/MainActivity;)V
    .locals 0

    .prologue
    .line 26
    iput-object p1, p0, Lcom/mj/mjapp/MainActivity$1;-&gt;this$0:Lcom/mj/mjapp/MainActivity;

    invoke-direct {p0}, Ljava/lang/Object;-&gt;&lt;init&gt;()V

    return-void
.end method


# virtual methods
.method public onClick(Landroid/view/View;)V
    .locals 3
    .param p1, &quot;view&quot;    # Landroid/view/View;

    .prologue
    .line 29
    iget-object v0, p0, Lcom/mj/mjapp/MainActivity$1;-&gt;this$0:Lcom/mj/mjapp/MainActivity;

    const-string v1, &quot;Hello world&quot;

    const/4 v2, 0x0

    invoke-static {v0, v1, v2}, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;

    move-result-object v0

    invoke-virtual {v0}, Landroid/widget/Toast;-&gt;show()V

    .line 30
    return-void
.end method
</code></pre><p>接下来我们选重点讲：</p>
<pre><code># interfaces
.implements Landroid/view/View$OnClickListener;
</code></pre><p>这句代码表示 当前类实现了 Landroid/view/View$OnClickListener;这个接口。</p>
<pre><code># annotations
.annotation system Ldalvik/annotation/EnclosingMethod;
    value = Lcom/mj/mjapp/MainActivity;-&gt;onCreate(Landroid/os/Bundle;)V
.end annotation

.annotation system Ldalvik/annotation/InnerClass;
    accessFlags = 0x0
    name = null
.end annotation
</code></pre><p>上面注解是对当前内部类的一个解释说明，</p>
<ul>
<li><p>.annotation system Ldalvik/annotation/EnclosingMethod; 这句代码说明当前内部类作用于一个方法。与EnclosingMethod对应的还有 EnclosingClass注解。</p>
</li>
<li><p>value = Lcom/mj/mjapp/MainActivity;-&gt;onCreate(Landroid/os/Bundle;)V 这句代码表示当前内部类位于Lcom/mj/mjapp/MainActivity;的onCreate方法内。</p>
</li>
<li><p>accessFlags = 0x0  accessFlags 访问标志是一个枚举值</p>
<p>该枚举的声明如下：</p>
<pre><code>enum {
    kDexVisibilityBuild      = 0x00,     /* annotation visibility */
    kDexVisibilityRuntime    = 0x01,
    kDexVisibilitySystem     = 0x02,
};
</code></pre><p>accessFlags = 0x0 表明它的属性是 Runtime。name为内部类的名称。接着继续往下看</p>
<h1 id="instance-fields"><a href="#instance-fields" class="headerlink" title="instance fields"></a>instance fields</h1><p> .field final synthetic this$0:Lcom/mj/mjapp/MainActivity;</p>
<p>声明一个外部内的实例对象this$0 ，通过这句代码我们可以看出每一个内部类都有一个指向外部类的引用。而且声明为final，synthetic表示该行代码是编译器生成的。</p>
</li>
</ul>
<pre><code># direct methods
.method constructor &lt;init&gt;(Lcom/mj/mjapp/MainActivity;)V
    .locals 0

    .prologue
    .line 26
    iput-object p1, p0, Lcom/mj/mjapp/MainActivity$1;-&gt;this$0:Lcom/mj/mjapp/MainActivity;

    invoke-direct {p0}, Ljava/lang/Object;-&gt;&lt;init&gt;()V

    return-void
.end method
</code></pre><p>这几行代码表示当前内部内的默认构造方法，在该构造方法中为 this$0 这个变量赋值为p1。这个p1是从哪儿来的？ 我们往回看外部类的onCreate方法，我们看到有这么一行代码</p>
<blockquote>
<p>invoke-direct {v1, p0}, Lcom/mj/mjapp/MainActivity$1;-&gt;<init>(Lcom/mj/mjapp/MainActivity;)V</init></p>
</blockquote>
<p>通过这行代码可以看出这个参数列表中的p0就是内部类的构造方法中的p1 。</p>
<ul>
<li>invoke-direct {p0}, Ljava/lang/Object;-&gt;<init>()V  调用 Ljava/lang/Object;对象的无参构造方法。</init></li>
</ul>
<p>接着看 内部类的onClick方法。</p>
<ul>
<li>.locals 3 表示声明了3个本地寄存器变量。</li>
<li>iget-object v0, p0, Lcom/mj/mjapp/MainActivity$1;-&gt;this$0:Lcom/mj/mjapp/MainActivity; 把this$0这个实例变量赋值给v0这个寄存器本地变量。</li>
<li>const-string v1, “Hello world” 把 “Hello world” 这个字符串赋值给 v1这个本地变量。</li>
<li>const/4 v2, 0x0 把0x0赋值给v2 这个本地变量。</li>
<li>invoke-static {v0, v1, v2}, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;  invoke-static指令表示调用Landroid/widget/Toast;这个类的makeText这个静态方法，v0,v1,v2作为三个参数传递给makeText方法。</li>
<li>move-result-object v0 把Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;这个方法的返回值赋值给v0。</li>
<li>invoke-virtual {v0}, Landroid/widget/Toast;-&gt;show()V 调用Toast的show()方法。</li>
</ul>
<p>至此 内部类的smali代码也分析完成。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/23/java线程学习笔记/" itemprop="url">
                  java线程学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-23T13:58:14+08:00" content="2016-06-23">
              2016-06-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/23/java线程学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/23/java线程学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><p>sleep()方法是类方法,也就是对当前线程而言的,程序员不能指定某个线程去sleep,只能是当前线程执行到sleep()方法时,睡眠指定的时间(让其它线程运行).事实上也只能是类方法,在当前线程上调用.试想如果你调用一个线程对象的sleep()方法,那么这个对象对应的线程如果不是正在运行,它如何sleep()?</p>
<p>所以只有当前线程,才能保证它可以调用sleep()方法，因为它正在执行。</p>
<p>调用sleep()的线程不会释放当前所获得的锁对象。</p>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3><p>yield()方法也是类方法,只在当前线程上调用,理由同上,它主是让当前线程放弃本次分配到的时间片。</p>
<h3 id="synchornized"><a href="#synchornized" class="headerlink" title="synchornized"></a>synchornized</h3><p>把一个单元声明为synchronized,就可以让在同一时间只有一个线程执行该单元块中的代码。</p>
<p>每个对象有且只有一把监视锁(monitor lock)，一次只能被一个线程获取。当一个线程获取了这一个锁<br>后,这段时间只有这个线程才能执行该synchronized块中代码,其它线程就只能等待这个线程释放锁后才能再获取.</p>
<pre><code>//对于同步块,synchronized获取的是参数中的对象锁:
synchronized(obj){
    //...............
}
</code></pre><p>因为只有对象类型才有对象锁，原始类型是没有对象锁的。所以synchronized括号中的参数只能是对象，不能是原始类型。</p>
<h3 id="wait-和notify-notifyAll"><a href="#wait-和notify-notifyAll" class="headerlink" title="wait() 和notify()/notifyAll()"></a>wait() 和notify()/notifyAll()</h3><p><strong>这三个方法是Object类的方法，不是Thread类的方法。</strong></p>
<p>当一个线程调用了一个对象的wait方法后,这个线程就进入了这个对象的休息室(waitset),这是一个虚拟的<br>对象,但JVM中一定存在这样的一个数据结构用来记录当前对象的休息室中有哪些线程在等待.<br>当一个线程进入等待时,它就会释放锁,让其它线程来获取这个锁. <strong>进入对象休息室中的线程，只能让其它线程调用同一个对象的notify()/notifyAll()方法。</strong></p>
<p>调用这三个对象的方法的线程必须要获得这三个对象的锁，否则会抛出java.lang.IllegalMonitorStateException异常。</p>
<p>所以请记住:</p>
<blockquote>
<p>线程要想调用一个对象的wait()方法就要先获得该对象的监视锁,而一旦调用wait()后又立即自动释放该锁</p>
</blockquote>
<p>notofy/notifyAll方法也必须在同步代码块中调用(也就是调用线程必须持有对象的锁)，他们的功能是这样的：</p>
<blockquote>
<p>女士们，先生们请注意，锁的对象我即将用完，请大家醒醒，准备一下，马上你们就能使用锁了。</p>
</blockquote>
<p>不同的是，notify方法只会唤醒一个正在等待的线程(至于唤醒谁，不确定！)，而notifyAll方法会唤醒所有正在等待的线程。还有一点需要特别强调：<strong>调用notify和notifyAll方法后，当前线程并不会立即放弃锁的持有权，而必须要等待当前同步代码块执行完才会让出锁</strong>。</p>
<h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>在以前的版本中，使用stop(),suspend()强制让线程停止或者挂起，这会导致一些意想不到的结果出现。所以在新版本的JDK中这几个方法已经被标记为Deprecated。</p>
<p>在新版本中在java中,线程的中断(interrupt)只是改变了线程的中断状态,至于这个中断状态改变后带来的结果,那是无法确定的,有时它更是让停止中的线程继续执行的唯一手段.不但不是让线程停止运行,反而是继续执行线程的手段.</p>
<p>在一个线程对象上调用interrupt()方法,真正有影响的是wait,join,sleep方法,当然这三个方法包括它们的重载方法.</p>
<ul>
<li><p>对于wait中等待notify/notifyAll唤醒的线程,其实这个线程已经”暂停”执行,因为它正在某一对象的休息室中,这时如果它的中断状态被改变,那么它就会抛出InterruptedException异常.这个InterruptedException异常不是线程抛出的,而是wait方法,也就是对象的wait方法内部会不断检查在此对象上休息的线程的状态,如果发现哪个线程的状态被置为已中断,则会抛出InterruptedException,意思就是这个线程不能再等待了,其意义就等同于唤醒它了.</p>
</li>
<li><p>对于sleep中的线程,如果你调用了Thread.sleep(一年);现在你后悔了,想让它早些醒过来,调用<br>interrupt()方法就是唯一手段,只有改变它的中断状态,让它从sleep中将控制权转到处理异常的catch语句中,然后再由catch中的处理转换到正常的逻辑.同样,地于join中的线程你也可以这样处理. </p>
<p>对于一般介绍多线程模式的书上,他们会这样来介绍:当一个线程被中断后,在进入wait,sleep,join方法时会抛出异常.是的,这一点也没有错,但是这有什么意义呢?如果你知道那个线程的状态已经处于中断状态,为什么还要让它进入这三个方法呢?</p>
</li>
</ul>
<p>在已经调用wait,join,sleep这三个方法的线程上调用interrupt()方法会让线程从这几个方法的”暂停”状态中恢复过来.这个恢复过来就可以包含两个目的:</p>
<ol>
<li><p>[可以使线程继续执行],那就是在catch语句中执行醒来后的逻辑,或由catch语句转回正常的逻辑.总之它是从wait,sleep,join的暂停状态活过来了.</p>
</li>
<li><p>[可以直接停止线程的运行],当然在catch中什么也不处理,或return,那么就完成了当前线程的使命,可以使在上面”暂停”的状态中立即真正的”停止”.</p>
</li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/Groovy学习笔记/" itemprop="url">
                  Groovy学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-18T22:24:30+08:00" content="2016-05-18">
              2016-05-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/18/Groovy学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/18/Groovy学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Groovy是一中运行在jvm上的动态语言<br>Groovy注释标记和Java一样，支持//或者/**/<br>Groovy语句可以不用分号结尾。Groovy为了尽量减少代码的输入，确实煞费苦心<br>Groovy中支持动态类型，即定义变量的时候可以不指定其类型。Groovy中，变量定义可以使用关键字def。注意，虽然def不是必须的，但是为了代码清晰，建议还是使用def关键字</p>
<pre><code>def variable1 = 1   //可以不使用分号结尾 
def  int x = 1  //变量定义时，也可以直接指定类型
</code></pre><p>当变量没有def等任何定义时，该变量全局有效。类似于javascript中的不用var定义的变量。</p>
<p>函数定义时，参数的类型也可以不指定。比如</p>
<pre><code>String testFunction(arg1,arg2){//无需指定参数类型
  ...
}
</code></pre><p>除了变量定义可以不指定类型外，Groovy中函数的返回值也可以是无类型的。比如：<br><strong>无类型的函数定义，必须使用def关键字</strong></p>
<pre><code>def  nonReturnTypeFunc(){
    last_line   //最后一行代码的执行结果就是本函数的返回值
}
</code></pre><p>如果指定了函数返回类型，则可不必加def关键字来定义函数</p>
<pre><code>String getString(){
   return&quot;I am a string&quot;
}
</code></pre><p>其实，所谓的无返回类型的函数，我估计内部都是按返回Object类型来处理的。毕竟，Groovy是基于Java的，而且最终会转成Java Code运行在JVM上</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>1  单引号’’中的内容严格对应Java中的String，不对$符号进行转义  </p>
<pre><code>defsingleQuote=&apos;I am $ dolloar&apos;  //输出就是I am $ dolloar
</code></pre><p>2  双引号””的内容则和脚本语言的处理有点像，如果字符中有$号的话，则它会$表达式先求值。  </p>
<pre><code>defdoubleQuoteWithoutDollar = &quot;I am one dollar&quot; //输出 I am one dollar  
def x = 1  
defdoubleQuoteWithDollar = &quot;I am $x dolloar&quot; //输出I am 1 dolloar  
</code></pre><p>3 三个引号’’’xxx’’’中的字符串支持随意换行 比如  </p>
<pre><code>defmultieLines = &apos;&apos;&apos; begin  
     line  1  
     line  2  
     end &apos;&apos;&apos;
</code></pre><p>最后，除了每行代码不用加分号外，Groovy中函数调用的时候还可以不加括号。比如：  </p>
<pre><code>println(&quot;test&quot;) ---&gt; println&quot;test&quot;  
</code></pre><p>调用函数要不要带括号，我个人意见是如果这个函数是Groovy API或者Gradle API中比较常用的，比如println，就可以不带括号。否则还是带括号。</p>
<h2 id="Groovy中的数据类型"><a href="#Groovy中的数据类型" class="headerlink" title="Groovy中的数据类型"></a>Groovy中的数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>作为动态语言，Groovy世界中的所有事物都是对象。所以，int，boolean这些Java中的基本数据类型，在Groovy代码中其实对应的是它们的包装数据类型。比如int对应为Integer，boolean对应为Boolean。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li>闭包中最后一行语句，表示该闭包的返回值，不论该语句是否冠名return关键字</li>
</ul>
<pre><code>def aClosure = {//闭包是一段代码，所以需要用花括号括起来..
Stringparam1, int param2 -&gt;  //这个箭头很关键。箭头前面是参数定义，箭头后面是代码
println&quot;this is code&quot; //这是代码，最后一句是返回值，
//也可以使用return，和Groovy中普通函数一样
}
</code></pre><p>闭包的调用</p>
<pre><code>aClosure(&quot;this is string&quot;, 100)  
</code></pre><ul>
<li>调用闭包的方法等于创建一个闭包实例。对于相同闭包创建出来的不同实例，他们的对象是不同的</li>
</ul>
<pre><code>v1 = c()  
v2 = c()  
assert v1 != v2  
</code></pre><ul>
<li>如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫it。</li>
</ul>
<p>比如：</p>
<pre><code>def greeting = { &quot;Hello, $it!&quot; }

assert greeting(&apos;Patrick&apos;) == &apos;Hello, Patrick!&apos;
等同于：
def greeting = { it -&gt; &quot;Hello, $it!&quot;}
assert greeting(&apos;Patrick&apos;) == &apos;Hello, Patrick!&apos;
但是，如果在闭包定义时，采用下面这种写法，则表示闭包没有参数！
def noParamClosure = { -&gt; true }
这个时候，我们就不能给noParamClosure传参数了！
noParamClosure (&quot;test&quot;)  &lt;==报错喔！
</code></pre><ul>
<li>省略圆括号</li>
</ul>
<p>Groovy中，当函数的最后一个参数是闭包的话，在调用该函数的时候可以把闭包拿到圆括号的外面<br>比如  </p>
<pre><code>def testClosure(int a1,String b1, Closure closure){  
     closure() //调用闭包  
}  
//那么调用的时候，就可以免括号！  
testClosure (4, &quot;test&quot;）{  
   println&quot;i am in closure&quot;  
} 
</code></pre><p>如果函数中只有一个参数，且该参数是闭包类型的话，在调用该函数的时候可以省略圆括号</p>
<pre><code>doLast{
    println &quot;Hello Word&quot;
}
//等同于
doLast({
    println &quot;Hello Word&quot;
})
</code></pre><p><strong>省略圆括号使得代码简洁，看起来更像脚本语言</strong></p>
<h2 id="Groovy脚步的运行原理"><a href="#Groovy脚步的运行原理" class="headerlink" title="Groovy脚步的运行原理"></a>Groovy脚步的运行原理</h2><p>Groovy和java一样，都是运行于jvm上的语言。所以Groovy语言在编译时，会被编译成jvm识别的classs文件。</p>
<p><img src="http://img.blog.csdn.net/20150905192824392?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>参考  <a href="http://blog.csdn.net/innost/article/details/48228651" target="_blank" rel="external">http://blog.csdn.net/innost/article/details/48228651</a></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/05/java-动态代理学习/" itemprop="url">
                  Java 动态代理学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-05T14:03:47+08:00" content="2016-05-05">
              2016-05-05
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/05/java-动态代理学习/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/05/java-动态代理学习/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java中代理分为2种， 静态代理和动态代理。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><img src="http://77fzym.com1.z0.glb.clouddn.com/proxy.png" alt=""></p>
<p>从图中可以看出，代理对象是客户端和真实对象之间的桥梁。代理对象要实现真实对象的所有公开方法（或者接口），而且当真实对象的接口修改的时候，代理对象也要做修改。而且在构造代理对象的时候，必须要知道真实对象。就是说代理对象和真实对象在编译时就已经绑定了。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>代理类获知或者被告知真实对象的类型、接口列表时，代理可以根据反射构造出真实对象来，进而调用真实对象的相应方法，这就是动态代理：<strong>代理类在编译时不需要知道具体要代理哪个真实对象，只有到了运行时才知道</strong>。</p>
<p>案例参考 <a href="http://www.cnblogs.com/flyoung2008/archive/2013/08/11/3251148.html" target="_blank" rel="external">http://www.cnblogs.com/flyoung2008/archive/2013/08/11/3251148.html</a></p>
<h3 id="Java字节码生成开源框架介绍–Javassist"><a href="#Java字节码生成开源框架介绍–Javassist" class="headerlink" title="Java字节码生成开源框架介绍–Javassist"></a><strong>Java字节码生成开源框架介绍–Javassist</strong></h3><p>Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目,通过使用Javassist对字节码操作为JBoss实现动态AOP框架。javassist是<a href="http://baike.baidu.com/view/309533.htm" target="_blank" rel="external">jboss</a>的一个子项目，其主要的优点，在于简单，而且快速。直接使用java编码的形式，而不需要了解虚拟机(但是ASM需要了解虚拟机指令)指令，就能动态改变类的结构，或者动态生成类。</p>
<pre><code>import javassist.ClassPool;  
import javassist.CtClass;  
import javassist.CtMethod;  
import javassist.CtNewMethod;  
public class MyGenerator {  

    public static void main(String[] args) throws Exception {  
        ClassPool pool = ClassPool.getDefault();  
        //创建Programmer类       
        CtClass cc= pool.makeClass(&quot;com.samples.Programmer&quot;);  
        //定义code方法  
        CtMethod method = CtNewMethod.make(&quot;public void code(){}&quot;, cc);  
        //插入方法代码  
        method.insertBefore(&quot;System.out.println(\&quot;I&apos;m a Programmer,Just Coding.....\&quot;);&quot;);  
        cc.addMethod(method);  
        //保存生成的字节码  
        cc.writeFile(&quot;d://temp&quot;);  
    }  
}  
</code></pre><p>通过JD-gui反编译工具打开Programmer.class 可以看到以下代码：</p>
<p><img src="http://77fzym.com1.z0.glb.clouddn.com/a.png" alt=""></p>
<h3 id="动态代理的内部实现"><a href="#动态代理的内部实现" class="headerlink" title="动态代理的内部实现"></a>动态代理的内部实现</h3><p>动态代理就是根据代理类实现的接口来动态生成class文件，然后根据这个class文件动态生成代理对象。</p>
<p>生成动态代理类的字节码并且保存到硬盘中：</p>
<p>JDK提供了<strong>sun.misc.ProxyGenerator.generateProxyClass(String proxyName,class[] interfaces)</strong> 底层方法来产生动态代理类的字节码：</p>
<p>下面定义了一个工具类，用来将生成的动态代理类保存到硬盘中：</p>
<pre><code>import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.Proxy;
import sun.misc.ProxyGenerator;

public class ProxyUtils {
/*
 * 将根据类信息 动态生成的二进制字节码保存到硬盘中，
 * 默认的是clazz目录下
     * params :clazz 需要生成动态代理类的类
     * proxyName : 为动态生成的代理类的名称
    &amp;nbsp;*/
public static void generateClassFile(Class clazz,String proxyName)
{
    //根据类信息和提供的代理类名称，生成字节码
    byte[] classFile =ProxyGenerator.generateProxyClass(proxyName, clazz.getInterfaces()); 
    String paths = clazz.getResource(&quot;.&quot;).getPath();
    System.out.println(paths);
    FileOutputStream out = null;  

    try {
        //保留到硬盘中
        out = new FileOutputStream(paths+proxyName+&quot;.class&quot;);  
        out.write(classFile);  
        out.flush();  
    } catch (Exception e) {  
        e.printStackTrace();  
    } finally {  
        try {  
            out.close();  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}
}
</code></pre><p>现在我们想将生成的代理类起名为“ElectricCarProxy”，并保存在硬盘，应该使用以下语句：</p>
<pre><code>ProxyUtils.generateClassFile(car.getClass(), &quot;ElectricCarProxy&quot;);
</code></pre><p>然后我们反编译生成的ElectricCarProxy.class文件,反编译之后看到的代码是：</p>
<p><strong>备注：代码中的 Subject接口 就是代理类实现的接口</strong></p>
<pre><code>import java.lang.reflect.*;   
public final class ProxySubject extends Proxy  implements Subject       
{   
    private static Method m1;   
    private static Method m0;   
    private static Method m3;   
    private static Method m2;   
    public ProxySubject(InvocationHandler invocationhandler)   
    {   
        super(invocationhandler);   
    }   
    public final boolean equals(Object obj)   
    {   
        try  
        {   
            return ((Boolean)super.h.invoke(this, m1, new Object[] {   
                obj   
            })).booleanValue();   
        }   
        catch(Error _ex) { }   
        catch(Throwable throwable)   
        {   
            throw new UndeclaredThrowableException(throwable);   
        }   
    }   
    public final int hashCode()   
    {   
        try  
        {   
            return ((Integer)super.h.invoke(this, m0, null)).intValue();   
        }   
        catch(Error _ex) { }   
        catch(Throwable throwable)   
        {   
            throw new UndeclaredThrowableException(throwable);   
        }   
    }   
    public final void doSomething()   
    {   
        try  
        {   
            super.h.invoke(this, m3, null);   
            return;   
        }   
        catch(Error _ex) { }   
        catch(Throwable throwable)   
        {   
            throw new UndeclaredThrowableException(throwable);   
        }   
    }   
    public final String toString()   
    {   
        try  
        {   
            return (String)super.h.invoke(this, m2, null);   
        }   
        catch(Error _ex) { }   
        catch(Throwable throwable)   
        {   
            throw new UndeclaredThrowableException(throwable);   
        }   
    }   
    static    
    {   
        try  
        {   
            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] {   
                Class.forName(&quot;java.lang.Object&quot;)   
            });   
            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);   
            m3 = Class.forName(&quot;Subject&quot;).getMethod(&quot;doSomething&quot;, new Class[0]);   
            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);   
        }   
        catch(NoSuchMethodException nosuchmethodexception)   
        {   
            throw new NoSuchMethodError(nosuchmethodexception.getMessage());   
        }   
        catch(ClassNotFoundException classnotfoundexception)   
        {   
            throw new NoClassDefFoundError(classnotfoundexception.getMessage());   
        }   
    }   
}
</code></pre><p>我们可以看到动态生成的ProxySubject 是继承Proxy类的。这就是<br><strong>为什么只能通过接口类来生成动态代理，而不是类来实现，因为java不支持多继承</strong>。<br>通过反编译之后的代码，我们可以看出调用代理类的一个方法时，代理类的方法会调用InvocationHandler的invoke方法，然后invoke方法再调用被代理对象的方法，所以我们在InvocationHandler的invoke方法的方法里做一些其它的处理操作，比如添加日志等等。</p>
<p>参考</p>
<p> <a href="http://blog.csdn.net/luanlouis/article/details/24589193" target="_blank" rel="external">http://blog.csdn.net/luanlouis/article/details/24589193</a></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/27/ADB-学习总结/" itemprop="url">
                  ADB 学习总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-27T16:39:10+08:00" content="2016-04-27">
              2016-04-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/27/ADB-学习总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/27/ADB-学习总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ADB 全称是Android Debug Bridge，android设备和模拟器是通过ADB来和PC机进行通信的，可以认为ADB是2者之间通信的桥梁。ADB采用的是cs模式来进行数据通信。</p>
<h2 id="ADB-有三个部分组成"><a href="#ADB-有三个部分组成" class="headerlink" title="ADB 有三个部分组成"></a>ADB 有三个部分组成</h2><ol>
<li>ADB客户端（DDMS）</li>
<li>ADB服务（运行在PC主机上 端口号5037）</li>
<li>adbd 守护服务（运行在模拟器或者android设备上)</li>
</ol>
<p><img src="http://77fzym.com1.z0.glb.clouddn.com/%E4%B8%8B%E8%BD%BD.png" alt="http://77fzym.com1.z0.glb.clouddn.com/%E4%B8%8B%E8%BD%BD.png"></p>
<p>当用户开始一个ADB客户端程序时，客户端首先会检查是否已经有一个 ADB 服务进程在运行，如果没有，它会启动一个服务进程；服务进程启动后，会与一个本地TCP端口5037进行绑定，并监听从ADB客户端发送过来的命令（所有的客户端都使用端口5037与服务进程进行通信）。</p>
<p>接着，服务端进程会配置所有正在运行的模拟器或者设备的链接：通过扫描5555 - 5585（模拟器/设备使用的端口范围）之间的奇数端口，服务端进程可以找到相应的模拟器/设备，接着找到相应的ADB守护进程，并对该端口进行配置。注意，每个模拟器/设备都需要一对连续的端口 - 奇数端口号用于ADB连接，偶数端口号用于控制台连接。</p>
<h2 id="Android设备ADB授权的原理"><a href="#Android设备ADB授权的原理" class="headerlink" title="Android设备ADB授权的原理"></a>Android设备ADB授权的原理</h2><p>用ADB调试Android设备时，首次连接时，会出现一个授权提示：</p>
<blockquote>
<p>error: device unauthorized. Please check the confirmation dialog on your device.</p>
</blockquote>
<p>这时候，正常情况下，在手机上会出现一个提示框，让用户确认是否授权这个PC设备允许调试，你只需要点击确认就可以了！</p>
<p><strong>工作原理是什么？</strong></p>
<p>在PC机上首次启动 ADB.exe进程时，ADB会在C盘的当前用户的目录下生成一个”.android”目录，生成一对密钥ADBkey(私钥)与ADBkey.pub(公钥)就存放在这个目录下。在电脑初次通过ADB和android设备通信的时候，PC端会把公钥(或者公钥的hash值)(fingerprint)发送给android设备，该公钥存放在android设备的”/data/misc/ADB/“目录下。当android设备的”/data/misc/ADB/“目录下已经存在该公钥时，就不发送这个文件，如果android设备没有这个文件的时候，就会发送PC上的公钥到android设备上的”/data/misc/ADB/“目录下，则会弹出提示框，让你确认是否允许这台机器进行ADB连接，当你点击了允许授权之后，android就会保存了这台PC的ADBkey.pub(公钥)；</p>
<p>参考 <a href="http://blog.csdn.net/sowhat_ah/article/details/43307907" target="_blank" rel="external">http://blog.csdn.net/sowhat_ah/article/details/43307907</a></p>
<h2 id="ADB常用命令"><a href="#ADB常用命令" class="headerlink" title="ADB常用命令"></a>ADB常用命令</h2><blockquote>
<p>查看已连接的设备<br>  adb devices</p>
</blockquote>
<hr>
<blockquote>
<p>安装软件<br>adb install <path_to_apk></path_to_apk></p>
</blockquote>
<hr>
<blockquote>
<p>拷贝文档到手机或者模拟器<br>adb push foo.txt /sdcard/foo.txt</p>
</blockquote>
<hr>
<blockquote>
<p>拷贝手机文件至电脑上<br>adb pull /sdcard/**.txt   D:\  </p>
</blockquote>
<hr>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/26/Binder的相关知识点/" itemprop="url">
                  Binder的相关知识点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-26T19:08:35+08:00" content="2016-04-26">
              2016-04-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/26/Binder的相关知识点/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/26/Binder的相关知识点/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p><strong>进程隔离</strong></p>
<blockquote>
<p>进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。</p>
</blockquote>
<p><strong>用户空间/内核空间</strong></p>
<p>简单理解如下：</p>
<p>Linux Kernel是操作系统的核心，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。</p>
<p>对于Kernel这么一个高安全级别的东西，显然是不容许其它的应用程序随便调用或访问的，所以需要对Kernel提供一定的保护机制，这个保护机制用来告诉那些应用程序，你只可以访问某些许可的资源，不许可的资源是拒绝被访问的，于是就把Kernel和上层的应用程序抽像的隔离开，分别称之为Kernel Space和User Space。</p>
<p>用户空间访问内核空间的唯一方式就是系统调用；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。</p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。处理器在特权等级高的时候才能执行那些特权CPU指令。</p>
<p>在Android系统中，这个运行在内核空间的，负责各个用户进程通过Binder通信的内核模块叫做Binder驱动  </p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/binder-model.png" alt=""></p>
<h3 id="Binder机制跨进程原理"><a href="#Binder机制跨进程原理" class="headerlink" title="Binder机制跨进程原理"></a>Binder机制跨进程原理</h3><p><strong>传统的2个用户空间的进程的通信方式</strong>：</p>
<blockquote>
<p>两个运行在用户空间的进程A和进程B如何完成通信呢？内核可以访问A和B的所有数据；所以，最简单的方式是通过内核做中转；假设进程A要给进程B发送数据，那么就先把A的数据copy到内核空间，然后把内核空间对应的数据copy到B就完成了；用户空间要操作内核空间，需要通过系统调用；刚好，这里就有两个系统调用：<em>copy_from_user</em>, <em>copy_to_user</em>。</p>
</blockquote>
<p><strong>Binder机制的通信原理</strong></p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/2016binder-procedure.png" alt=""></p>
<p>假设Client进程想要调用Server进程的object对象的一个方法add;对于这个跨进程通信过程，我们来看看Binder机制是如何做的。 （通信是一个广泛的概念，只要一个进程能调用另外一个进程里面某对象的方法，那么具体要完成什么通信内容就很容易了。）</p>
<p>首先，Server进程要向SM注册；告诉自己是谁，自己有什么能力；在这个场景就是Server告诉SM，它叫zhangsan，它有一个object对象，可以执行add 操作；于是SM建立了一张表：zhangsan这个名字对应进程Server;</p>
<p>然后Client向SM查询：我需要联系一个名字叫做zhangsan的进程里面的object对象；这时候关键来了：<strong>进程之间通信的数据都会经过运行在内核空间里面的驱动，驱动在数据流过的时候做了一点手脚</strong>，它并不会给Client进程返回一个真正的object对象，而是返回一个看起来跟object一模一样的代理对象objectProxy，这个objectProxy也有一个add方法，但是这个add方法没有Server进程里面object对象的add方法那个能力；objectProxy的add只是一个傀儡，它唯一做的事情就是把参数包装然后交给驱动。(这里我们简化了SM的流程，见下文)</p>
<p>但是Client进程并不知道驱动返回给它的对象动过手脚，毕竟伪装的太像了，如假包换。Client开开心心地拿着objectProxy对象然后调用add方法；我们说过，这个add什么也不做，直接把参数做一些包装然后直接转发给Binder驱动。</p>
<p>驱动收到这个消息，发现是这个objectProxy；一查表就明白了：我之前用objectProxy替换了object发送给Client了，它真正应该要访问的是object对象的add方法；于是Binder驱动通知Server进程，调用你的object对象的add方法，然后把结果发给我，Sever进程收到这个消息，照做之后将结果返回驱动，驱动然后把结果返回给Client进程；于是整个过程就完成了。</p>
<p>由于驱动返回的objectProxy与Server进程里面原始的object是如此相似，给人感觉好像是直接把Server进程里面的对象object传递到了Client进程；因此，我们可以说Binder对象是可以进行跨进程传递的对象</p>
<p>但事实上我们知道，Binder跨进程传输并不是真的把一个对象传输到了另外一个进程；传输过程好像是Binder跨进程穿越的时候，它在一个进程留下了一个真身，在另外一个进程幻化出一个影子（这个影子可以很多个）；Client进程的操作其实是对于影子的操作，影子利用<strong>Binder驱动</strong>最终让真身完成操作。</p>
<p>理解这一点非常重要；务必仔细体会。另外，Android系统实现这种机制使用的是代理模式, 对于Binder的访问，如果是在同一个进程（不需要跨进程），那么直接返回原始的Binder实体；如果在不同进程，那么就给他一个代理对象（影子）；我们在系统源码以及AIDL的生成代码里面可以看到很多这种实现。</p>
<p>另外我们为了简化整个流程，隐藏了SM这一部分驱动进行的操作；实际上，由于SM与Server通常不在一个进程，Server进程向SM注册的过程也是跨进程通信，驱动也会对这个过程进行暗箱操作：SM中存在的Server端的对象实际上也是代理对象，后面Client向SM查询的时候，驱动会给Client返回另外一个代理对象。Sever进程的本地对象仅有一个，其他进程所拥有的全部都是它的代理。</p>
<p>一句话总结就是：</p>
<blockquote>
<p>Client进程只不过是持有了Server端的代理；代理对象协助驱动完成了跨进程通信。</p>
</blockquote>
<h3 id="Binder到底是什么？"><a href="#Binder到底是什么？" class="headerlink" title="Binder到底是什么？"></a>Binder到底是什么？</h3><p>Binder的设计采用了面向对象的思想，在Binder通信模型的四个角色里面；他们的代表都是“Binder”，这样，对于Binder通信的使用者而言，Server里面的Binder和Client里面的Binder没有什么不同，一个Binder对象就代表了所有，它不用关心实现的细节，甚至不用关心驱动以及SM的存在；这就是抽象。</p>
<ul>
<li>通常意义下，Binder指的是一种通信机制；我们说AIDL使用Binder进行通信，指的就是Binder这种IPC机制。</li>
<li>对于Server进程来说，Binder指的是Binder本地对象</li>
<li>对于Client来说，Binder指的是Binder代理对象，它只是Binder本地对象的一个远程代理；对这个Binder代理对象的操作，会通过驱动最终转发到Binder本地对象上去完成；对于一个拥有Binder对象的使用者而言，它无须关心这是一个Binder代理对象还是Binder本地对象；对于代理对象的操作和对本地对象的操作对它来说没有区别。</li>
<li>对于传输过程而言，Binder是可以进行跨进程传递的对象；Binder驱动会对具有跨进程传递能力的对象做特殊处理：自动完成代理对象和本地对象的转换。</li>
</ul>
<blockquote>
<p>面向对象思想的引入将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体（本地对象）位于一个进程中，而它的引用（代理对象）却遍布于系统的各个进程之中。最诱人的是，这个引用和java里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给其它进程，让大家都能访问同一Server，就象将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的Binder对象以及星罗棋布的引用仿佛粘接各个应用程序的胶水，这也是Binder在英文里的原意。</p>
</blockquote>
<h3 id="驱动里面的Binder"><a href="#驱动里面的Binder" class="headerlink" title="驱动里面的Binder"></a>驱动里面的Binder</h3><p>我们现在知道，Server进程里面的Binder对象指的是Binder本地对象，Client里面的对象值得是Binder代理对象；在Binder对象进行跨进程传递的时候，Binder驱动会自动完成这两种类型的转换；因此Binder驱动必然保存了每一个跨越进程的Binder对象的相关信息；在驱动中，Binder本地对象的代表是一个叫做binder_node的数据结构，Binder代理对象是用binder_ref代表的；有的地方把Binder本地对象直接称作Binder实体，把Binder代理对象直接称作Binder引用（句柄），其实指的是Binder对象在驱动里面的表现形式；</p>
<h3 id="深入理解Java层的Binder"><a href="#深入理解Java层的Binder" class="headerlink" title="深入理解Java层的Binder"></a>深入理解Java层的Binder</h3><p><strong>IBinder/IInterface/Binder/BinderProxy/Stub</strong></p>
<p>我们使用AIDL接口的时候，经常会接触到这些类，那么这每个类代表的是什么呢？</p>
<ul>
<li>IBinder是一个接口，它代表了一种跨进程传输的能力；只要实现了这个接口，就能将这个对象进行跨进程传递；这是驱动底层支持的；在跨进程数据流经驱动的时候，驱动会识别IBinder类型的数据，从而自动完成不同进程Binder本地对象以及Binder代理对象的转换。</li>
<li>IBinder负责数据传输，那么client与server端的调用契约（这里不用接口避免混淆）呢？这里的IInterface代表的就是远程server对象具有什么能力。具体来说，就是aidl里面的接口。</li>
<li>Java层的Binder类，代表的其实就是Binder本地对象。BinderProxy类是Binder类的一个内部类，它代表远程进程的Binder对象的本地代理；这两个类都继承自IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder驱动会自动完成这两个对象的转换。</li>
<li>在使用AIDL的时候，编译工具会给我们生成一个Stub的静态内部类；这个类继承了Binder, 说明它是一个Binder本地对象，它实现了IInterface接口，表明它具有远程Server承诺给Client的能力；Stub是一个抽象类，具体的IInterface的相关实现需要我们手动完成，这里使用了策略模式。</li>
</ul>
<p> 参考：<a href="http://weishu.me/2016/01/12/binder-index-for-newer/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://weishu.me/2016/01/12/binder-index-for-newer/?utm_source=tuicool&amp;utm_medium=referral</a></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/14/Bitmap-Drawable-byte-三者之间的转换/" itemprop="url">
                  Bitmap,Drawable,byte[] 三者之间的转换
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-14T14:57:25+08:00" content="2016-04-14">
              2016-04-14
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/14/Bitmap-Drawable-byte-三者之间的转换/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/14/Bitmap-Drawable-byte-三者之间的转换/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Bitmap-gt-Drawable"><a href="#Bitmap-gt-Drawable" class="headerlink" title="Bitmap-&gt;Drawable"></a>Bitmap-&gt;Drawable</h3><pre><code>private Drawable transBitmapToBitmapDrawable(Bitmap bitmap){
    BitmapDrawable bd=new BitmapDrawable(getResources(),bitmap); 
    return bd;
}
</code></pre><blockquote>
<p>BitmapDrawable是Drawable的子类。</p>
</blockquote>
<h3 id="Drawable-gt-Bitmap"><a href="#Drawable-gt-Bitmap" class="headerlink" title="Drawable-&gt;Bitmap"></a>Drawable-&gt;Bitmap</h3><pre><code>private void drawableToBitamp(Drawable drawable){
     BitmapDrawable bd = (BitmapDrawable) drawable;
     bitmap = bd.getBitmap();
}
</code></pre><h3 id="Bitmap-gt-byte"><a href="#Bitmap-gt-byte" class="headerlink" title="Bitmap-&gt;byte[ ]"></a>Bitmap-&gt;byte[ ]</h3><pre><code>private byte[] transBitmapToByteArr(Bitmap bitmap){
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        bitmap.compress(Bitmap.CompressFormat.PNG, 100, baos);
        return baos.toByteArray();
}
</code></pre><p>在写这边文章的时候，有个小疑惑，为什么用的是 <strong>ByteArrayOutputStream</strong>，而不是 <strong>ByteArrayInputStream</strong>，因为 这个输入和输出是相对的概念。过程的执行体是 <strong>bitmap</strong>，当将 <strong>bitmap</strong> 的数据输出到 <strong>byte[]</strong> 这个过程，相对于 <strong>bitmap</strong> 来说是个输出的过程，所以用 <strong>ByteArrayOutputStream</strong> ， 这是我的理解。</p>
<h3 id="byte-gt-Bitmap"><a href="#byte-gt-Bitmap" class="headerlink" title="byte[ ] -&gt; Bitmap"></a>byte[ ] -&gt; Bitmap</h3><pre><code>private Bitmap transByteArrToBitmap(byte[] bytes){
    return BitmapFactory.decodeByteArray(bytes, 0, bytes.length);
}
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/12/我的第一篇hexo博客/" itemprop="url">
                  我的第一篇hexo博客
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-12T13:31:42+08:00" content="2016-04-12">
              2016-04-12
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/12/我的第一篇hexo博客/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/12/我的第一篇hexo博客/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>终于把hexo搭建好了，以后就可以用这个写博客了 !!!</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="mike" />
          <p class="site-author-name" itemprop="name">mike</p>
          <p class="site-description motion-element" itemprop="description">android , java</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/" target="_blank" title="GitHub">
                  
                    <i class="fa fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mike</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"MINJIE1"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
